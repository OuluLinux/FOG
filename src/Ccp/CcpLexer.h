#ifndef FLEX_HEADER_CcpLexer_hxx
#define FLEX_HEADER_CcpLexer_hxx


#define YY_CcpLexer_CHAR unsigned char

/*  A lexical scanner header generated by flex */
/*  MODIFIED FOR C++ CLASS BY Alain Coetmeur: coetmeur(at)icdc.fr */
/*  Note that (at) mean the 'at' symbol that I cannot write */
/*  because it is expanded to the class name */
/*  made at Informatique-CDC, Research&development department */
/*  company from the Caisse Des Depots et Consignations */


/* ********************************************/
/*  SYSTEM dependent declaration, includes... */
/* ********************************************/
/*  cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
#ifdef c_plusplus
#ifndef __cplusplus
#define __cplusplus
#endif
#endif
#ifdef __cplusplus
#ifndef YY_USE_PROTOS
#define YY_USE_PROTOS
#endif
#ifndef YY_USE_CLASS
#define YY_USE_CLASS
#endif
#else /*  ! __cplusplus */
#ifdef __STDC__
#ifdef __GNUC__
#else
#endif /*  __GNUC__ */
#ifndef YY_USE_PROTOS
#define YY_USE_PROTOS
#endif
#endif /*  __STDC__ */
#endif /*  ! __cplusplus */
/* ********************************************/
/*  COMPILER DEPENDENT   MACROS               */
/* ********************************************/
/*  use prototypes in function declarations */
#ifndef YY_PROTO
#ifdef YY_USE_PROTOS
#define YY_PROTO(proto) proto
#else
#define YY_PROTO(proto) ()
#endif
#endif
#include <stdio.h>




/*  % here is the declaration from section1 %header{  */ 

#define YY_CcpLexer_INHERIT  : public PrimPrint

#define YY_CcpLexer_CONSTRUCTOR_PARAM  std::istream *inputStream, const PrimString& fileName, std::ostream *outputStream

#define YY_CcpLexer_CONSTRUCTOR_INIT  :\
 _string_buffer(0), \
 _string_buffer_capacity(0), \
 _context(fileName)

#define YY_CcpLexer_CONSTRUCTOR_CODE  \
 yyin = inputStream; \
 yyout = outputStream

#define YY_CcpLexer_WRAP_NOCODE 

#define YY_CcpLexer_LEX_PARAM  CcpParserValue& yylval

#define YY_CcpLexer_IOSTREAM 

#define YY_CcpLexer_MEMBERS  \
 private: \
  TYPEDECL_SINGLE(CcpLexer, PrimPrint) \
  PrimAdoptedArray<unsigned char> _string_buffer; \
  unsigned int _string_buffer_capacity; \
  CcpLexerContext _context; \
  PrimMapOfRefToConst<CcpDefine> _defines; \
 private: \
  void advance(int numCols) { _context.advance(numCols); } \
  bool expand_line(); \
  void got_include(); \
  void got_keyword(CcpParserValue& yylval); \
  void got_line(CcpParserValue& yylval); \
  void got_token(); \
  std::ostream& message(std::ostream& s, const char *msg) \
   { return _context.message(s, msg, yytext, yyleng); } \
  bool set_string_buffer_capacity(unsigned int aCapacity); \
  const char *text() const { return (const char *)yytext; } \
 public: \
  void add(const CcpDefine& aDefine) { _defines.add(aDefine); } \
  void diagnostic(const char *msg); \
  void error(const char *msg); \
  const char *file() const { return _context.file(); } \
  void warning(const char *msg);



#ifdef YY_USE_CLASS
#ifdef YY_CcpLexer_IOSTREAM
#include <iostream>
#define YY_CcpLexer_IFILE std::istream
#define YY_CcpLexer_OFILE std::ostream 
#define YY_CcpLexer_ERRFILE std::cerr

#ifndef YY_CcpLexer_IFILE_DEFAULT
#define YY_CcpLexer_IFILE_DEFAULT &std::cin
#endif

#ifndef YY_CcpLexer_OFILE_DEFAULT
#define YY_CcpLexer_OFILE_DEFAULT &std::cout
#endif

#endif
#endif

#ifndef YY_CcpLexer_IFILE
#define YY_CcpLexer_IFILE FILE 
#endif

#ifndef YY_CcpLexer_OFILE
#define YY_CcpLexer_OFILE FILE 
#endif

#ifndef YY_CcpLexer_ERRFILE
#define YY_CcpLexer_ERRFILE stderr
#endif

#ifndef YY_CcpLexer_IFILE_DEFAULT
#define YY_CcpLexer_IFILE_DEFAULT stdin
#endif

#ifndef YY_CcpLexer_OFILE_DEFAULT
#define YY_CcpLexer_OFILE_DEFAULT stdout
#endif




#ifndef YY_CcpLexer_TEXT
#define YY_CcpLexer_TEXT yytext
#endif
#ifndef YY_CcpLexer_LENG
#define YY_CcpLexer_LENG yyleng
#endif
#ifndef YY_CcpLexer_IN
#define YY_CcpLexer_IN yyin
#endif
#ifndef YY_CcpLexer_OUT
#define YY_CcpLexer_OUT yyout
#endif

#ifndef YY_CcpLexer_LEX_RETURN
#define YY_CcpLexer_LEX_RETURN int
#else
#ifndef YY_CcpLexer_LEX_DEFINED
#define YY_CcpLexer_LEX_DEFINED 
#endif
#endif

#ifndef YY_CcpLexer_LEX
#define YY_CcpLexer_LEX yylex
#else
#ifndef YY_CcpLexer_LEX_DEFINED
#define YY_CcpLexer_LEX_DEFINED 
#endif
#endif

#ifndef YY_CcpLexer_LEX_PARAM
#ifndef YY_USE_PROTOS
#define YY_CcpLexer_LEX_PARAM 
#else
#define YY_CcpLexer_LEX_PARAM void
#endif
#else
#ifndef YY_CcpLexer_LEX_DEFINED
#define YY_CcpLexer_LEX_DEFINED 
#endif
#endif

#ifndef YY_CcpLexer_LEX_PARAM_DEF
#define YY_CcpLexer_LEX_PARAM_DEF
#else
#ifndef YY_CcpLexer_LEX_DEFINED
#define YY_CcpLexer_LEX_DEFINED 
#endif
#endif

#ifndef YY_CcpLexer_RESTART
#define YY_CcpLexer_RESTART yyrestart
#endif
#ifndef YY_CcpLexer_SWITCH_TO_BUFFER
#define YY_CcpLexer_SWITCH_TO_BUFFER yy_switch_to_buffer
#endif
#ifndef YY_CcpLexer_LOAD_BUFFER_STATE
#define YY_CcpLexer_LOAD_BUFFER_STATE yy_load_buffer_state
#endif

#ifndef YY_CcpLexer_CREATE_BUFFER
#define YY_CcpLexer_CREATE_BUFFER yy_create_buffer
#ifndef YY_USE_CLASS
#ifndef yy_new_buffer
#define yy_new_buffer yy_create_buffer
#endif
#endif
#endif
#ifndef YY_CcpLexer_DELETE_BUFFER
#define YY_CcpLexer_DELETE_BUFFER yy_delete_buffer
#endif
#ifndef YY_CcpLexer_INIT_BUFFER
#define YY_CcpLexer_INIT_BUFFER yy_init_buffer
#endif



#ifdef YY_CcpLexer_FLEX_DEBUG
#ifndef YY_CcpLexer_DEBUG
#define YY_CcpLexer_DEBUG 1
#endif
#else
#ifndef YY_CcpLexer_DEBUG
#define YY_CcpLexer_DEBUG 0
#endif
#endif

#if YY_CcpLexer_DEBUG != 0
#ifndef YY_CcpLexer_DEBUG_FLAG
#define YY_CcpLexer_DEBUG_FLAG yy_flex_debug
#endif
#ifndef YY_CcpLexer_DEBUG_INIT
#define YY_CcpLexer_DEBUG_INIT 1
#endif
#endif




#ifndef YY_USE_CLASS
#ifndef YY_CcpLexer_CURRENT_BUFFER
#define YY_CcpLexer_CURRENT_BUFFER yy_current_buffer
#endif
typedef struct yy_buffer_state *YY_BUFFER_STATE;

extern void YY_CcpLexer_RESTART YY_PROTO(( YY_CcpLexer_IFILE *input_file ));
extern void YY_CcpLexer_SWITCH_TO_BUFFER YY_PROTO(( YY_BUFFER_STATE new_buffer ));
extern void YY_CcpLexer_LOAD_BUFFER_STATE YY_PROTO(( void ));
extern YY_BUFFER_STATE YY_CcpLexer_CREATE_BUFFER YY_PROTO(( YY_CcpLexer_IFILE *file, int size ));
extern void YY_CcpLexer_DELETE_BUFFER YY_PROTO(( YY_BUFFER_STATE b ));
extern void YY_CcpLexer_INIT_BUFFER YY_PROTO(( YY_BUFFER_STATE b, YY_CcpLexer_IFILE *file ));

#if YY_CcpLexer_DEBUG != 0
extern int YY_CcpLexer_DEBUG_FLAG ;
#endif
extern YY_CcpLexer_CHAR  *YY_CcpLexer_TEXT;
extern int YY_CcpLexer_LENG;
extern YY_CcpLexer_IFILE *YY_CcpLexer_IN;
extern YY_CcpLexer_OFILE *YY_CcpLexer_OUT;
#ifdef YY_CcpLexer_LEX_DEFINED
extern YY_CcpLexer_LEX_RETURN YY_CcpLexer_LEX ( YY_CcpLexer_LEX_PARAM )
YY_CcpLexer_LEX_PARAM_DEF
#else
#ifndef YY_DECL
extern YY_CcpLexer_LEX_RETURN YY_CcpLexer_LEX ( YY_CcpLexer_LEX_PARAM )
YY_CcpLexer_LEX_PARAM_DEF
#else
/*  no declaration if oldstyle flex */
#endif
#endif
#else

#ifndef YY_CcpLexer_CURRENT_BUFFER
#define YY_CcpLexer_CURRENT_BUFFER YY_CURRENT_BUFFER
#endif
#ifndef YY_CcpLexer_CLASS
#define YY_CcpLexer_CLASS CcpLexer
#endif
#ifndef YY_CcpLexer_ECHO
#define YY_CcpLexer_ECHO yy_echo
#endif
#ifdef YY_CcpLexer_ECHO_PURE
#define YY_CcpLexer_ECHO_NOCODE
#endif

#ifndef YY_CcpLexer_ECHO_CODE
#ifndef YY_CcpLexer_IOSTREAM
#define YY_CcpLexer_ECHO_CODE fwrite( (char *) YY_CcpLexer_TEXT, YY_CcpLexer_LENG, 1, YY_CcpLexer_OUT );
#else
#define YY_CcpLexer_ECHO_CODE (YY_CcpLexer_OUT->write( (char *) YY_CcpLexer_TEXT, YY_CcpLexer_LENG));
#endif
#endif

#ifndef YY_CcpLexer_INPUT
#define YY_CcpLexer_INPUT yy_input
#endif
#ifdef YY_CcpLexer_INPUT_PURE
#define YY_CcpLexer_INPUT_NOCODE
#endif

#ifndef YY_CcpLexer_INPUT_CODE
#ifndef YY_CcpLexer_IOSTREAM
#define YY_CcpLexer_INPUT_CODE return result= fread(  buffer, 1,max_size,YY_CcpLexer_IN );
#else
#define YY_CcpLexer_INPUT_CODE if(YY_CcpLexer_IN->eof())  result=0;else {YY_CcpLexer_IN->read(buffer,max_size);result=YY_CcpLexer_IN->gcount();YY_CcpLexer_IN->clear(YY_CcpLexer_IN->rdstate()&(~std::ios::failbit));if(YY_CcpLexer_IN->bad()) result= -1;} return result;
#endif
#endif

#ifdef YY_CcpLexer_FATAL_ERROR_PURE
#define YY_CcpLexer_FATAL_ERRO_NOCODE
#endif
#ifndef YY_CcpLexer_FATAL_ERROR
#define YY_CcpLexer_FATAL_ERROR yy_fatal_error
#endif

#ifndef YY_CcpLexer_FATAL_ERROR_CODE
#ifndef YY_CcpLexer_IOSTREAM
#define YY_CcpLexer_FATAL_ERROR_CODE fputs( msg, YY_CcpLexer_ERRFILE );putc( '\n', YY_CcpLexer_ERRFILE );exit( 1 );
#else
#define YY_CcpLexer_FATAL_ERROR_CODE YY_CcpLexer_ERRFILE<< msg << std::endl;exit( 1 );
#endif
#endif

#ifndef YY_CcpLexer_WRAP
#define YY_CcpLexer_WRAP yy_wrap
#endif
#ifdef YY_CcpLexer_WRAP_PURE
#define YY_CcpLexer_WRAP_NOCODE
#endif
#ifndef YY_CcpLexer_WRAP_CODE
#define YY_CcpLexer_WRAP_CODE return 1;
#endif


#ifndef YY_CcpLexer_INHERIT
#define YY_CcpLexer_INHERIT
#endif
#ifndef YY_CcpLexer_MEMBERS
#define YY_CcpLexer_MEMBERS 
#endif
#ifndef YY_CcpLexer_CONSTRUCTOR_PARAM
#define YY_CcpLexer_CONSTRUCTOR_PARAM
#endif
#ifndef YY_CcpLexer_CONSTRUCTOR_CODE
#define YY_CcpLexer_CONSTRUCTOR_CODE
#endif
#ifndef YY_CcpLexer_CONSTRUCTOR_INIT
#define YY_CcpLexer_CONSTRUCTOR_INIT
#endif
#ifndef YY_CcpLexer_DESTRUCTOR_CODE
#define YY_CcpLexer_DESTRUCTOR_CODE
#endif
typedef struct yy_buffer_state *YY_BUFFER_STATE;

class YY_CcpLexer_CLASS YY_CcpLexer_INHERIT
{
 private:/*  data */
 YY_CcpLexer_CHAR  *yy_c_buf_p;
 YY_CcpLexer_CHAR  yy_hold_char;
 int yy_n_chars;
 int yy_init;
 int yy_start;
 int yy_did_buffer_switch_on_eof;
 private: /*  functions */
 void yy_initialize();
 int input();
 int yyinput() {return input();};
 int yy_get_next_buffer();
 void yyunput( YY_CcpLexer_CHAR  c, YY_CcpLexer_CHAR  *buf_ptr );
 /*  use long instead of yy_state_type because it is undef */
 long yy_get_previous_state_ ( void );
 long yy_try_NUL_trans_  ( long current_state_ );
 protected:/*  non virtual */
 YY_BUFFER_STATE YY_CcpLexer_CURRENT_BUFFER;
 void YY_CcpLexer_RESTART ( YY_CcpLexer_IFILE *input_file );
 void YY_CcpLexer_SWITCH_TO_BUFFER( YY_BUFFER_STATE new_buffer );
 void YY_CcpLexer_LOAD_BUFFER_STATE( void );
 YY_BUFFER_STATE YY_CcpLexer_CREATE_BUFFER( YY_CcpLexer_IFILE *file, int size );
 void YY_CcpLexer_DELETE_BUFFER( YY_BUFFER_STATE b );
 void YY_CcpLexer_INIT_BUFFER( YY_BUFFER_STATE b, YY_CcpLexer_IFILE *file );
 protected: /*  virtual */
 virtual void YY_CcpLexer_ECHO()
#ifdef YY_CcpLexer_ECHO_PURE
  =0
#endif
  ;
 virtual int  YY_CcpLexer_INPUT(char  *buf,int &result,int max_size)
#ifdef YY_CcpLexer_INPUT_PURE
  =0
#endif
  ;
 virtual void  YY_CcpLexer_FATAL_ERROR(const char *msg)
#ifdef YY_CcpLexer_FATAL_ERROR_PURE
  =0
#endif
  ;
 virtual int  YY_CcpLexer_WRAP()
#ifdef YY_CcpLexer_WRAP_PURE
  =0
#endif
  ;
 public:
 YY_CcpLexer_CHAR  *YY_CcpLexer_TEXT;
 int YY_CcpLexer_LENG;
 YY_CcpLexer_IFILE *YY_CcpLexer_IN;
 YY_CcpLexer_OFILE *YY_CcpLexer_OUT;
 YY_CcpLexer_LEX_RETURN YY_CcpLexer_LEX ( YY_CcpLexer_LEX_PARAM);
 YY_CcpLexer_CLASS(YY_CcpLexer_CONSTRUCTOR_PARAM) ;
 virtual ~YY_CcpLexer_CLASS() ;
#if YY_CcpLexer_DEBUG != 0
 int YY_CcpLexer_DEBUG_FLAG;
#endif
 public: /*  added members */
 YY_CcpLexer_MEMBERS 
};
#endif



/*  declaration of externs for public use of yylex scanner */

/*  % here is the declaration from section2 %header{ */ 

#endif


/*  end of generated header */
