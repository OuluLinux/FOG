#include <Ccp/CcpIncludeAll.h>

#define YY_CHAR unsigned char

/*  A lexical scanner generated by flex */
/*  scanner skeleton version:
 * $Header: /flex_pp/flexskel.cc 3     2/09/98 3:48p Willink $
 */
/*  MODIFIED FOR C++ CLASS BY Alain Coetmeur: coetmeur(at)icdc.fr */
/*  Note that (at) mean the 'at' symbol that I cannot write */
/*  because it is expanded to the class name */
/*  made at Informatique-CDC, Research&development department */
/*  company from the Caisse Des Depots et Consignations */
/*  institutional financial group  */

/*  theses symbols are added before this file */
/*  #define YY_CHAR 'unsigned char' if 8bit or 'char' if 7bit */
/*  #define FLEX_DEBUG if debug mode */
#define FLEX_SCANNER
/*  cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
#ifdef c_plusplus
#ifndef __cplusplus
#define __cplusplus
#endif
#endif
/*  Old MSC, before c7 */
#ifdef MSDOS
#ifndef _MSDOS
#define _MSDOS
#endif
#endif
/*  turboc */
#ifdef __MSDOS__
#ifndef _MSDOS
#define _MSDOS
#endif
#endif

#ifdef __cplusplus
#include <stdlib.h>
#define YY_USE_CONST
#define YY_USE_PROTOS
#ifndef YY_USE_CLASS
#define YY_USE_CLASS
#endif
#if !defined(_MSDOS) && !defined(_WIN32)
//#include <osfcn.h>
#endif
#else   /*  ! __cplusplus */
#ifdef __STDC__
#ifdef __GNUC__
#include <stddef.h>
void *malloc( size_t );
void free( void* );
int read();
#else
#include <stdlib.h>
#endif  /*  __GNUC__ */
#define YY_USE_PROTOS
#define YY_USE_CONST
#endif  /*  __STDC__ */
#endif  /*  ! __cplusplus */
#ifdef __TURBOC__
#define YY_USE_CONST
#endif
#include <stdio.h>


/* ********************************************/
/*  COMPILER DEPENDENT   MACROS               */
/* ********************************************/
/*  use prototypes in function declarations */
/*  the "const" storage-class-modifier is valid */
#ifndef YY_USE_CONST
#define const
#endif
/*  use prototypes in function declarations */
#ifndef YY_PROTO
#ifdef YY_USE_PROTOS
#define YY_PROTO(proto) proto
#else
#define YY_PROTO(proto) ()
#endif
#endif


/* ********************/
/*  parameters        */

/*  amount of stuff to slurp up with each read */
#ifndef YY_READ_BUF_SIZE
#define YY_READ_BUF_SIZE 8192
#endif
/*  size of default input buffer */
#ifndef YY_BUF_SIZE
#define YY_BUF_SIZE (YY_READ_BUF_SIZE * 2) 
#endif

/* **********************************/
/*  to be redefined for application */

/*  returned upon end-of-file */
#define YY_END_TOK 0
/*  no semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#define yyterminate() return ( YY_NULL )

/*  code executed at the end of each rule */
#define YY_BREAK break;

/*  #define YY_USER_ACTION */
/*  #define YY_USER_INIT */


#ifndef YY_USE_CLASS
/*  copy whatever the last rule matched to the standard output */
/*  cast to (char *) is because for 8-bit chars, yy___text is (unsigned char *) */
/*  this used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite()
 */
#define ECHO (void) fwrite( (char *) yy___text, yy___leng, 1, yy___out )

/*  gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#ifdef _MSDOS
#define YY_INPUT(buf,result,max_size) \
 if ( (result = fread(buf,1,max_size,yy___in)) < 0 ) \
     YY_FATAL_ERROR( "fread() in flex scanner failed" );
#else
#define YY_INPUT(buf,result,max_size) \
 if ( (result = read( fileno(yy___in), (char *) buf, max_size )) < 0 ) \
     YY_FATAL_ERROR( "read() in flex scanner failed" );

#endif
/*  report a fatal error */

/*  The funky do-while is used to turn this macro definition into
 * a single C statement (which needs a semi-colon terminator).
 * This avoids problems with code like:
 *
 *      if ( something_happens )
 *              YY_FATAL_ERROR( "oops, the something happened" );
 *      else
 *              everything_okay();
 *
 * Prior to using the do-while the compiler would get upset at the
 * "else" because it interpreted the "if" statement as being all
 * done when it reached the ';' after the YY_FATAL_ERROR() call.
 */

#define YY_FATAL_ERROR(msg) \
 do \
  { \
  (void) fputs( msg, yy___stderr  ); \
  (void) putc( '\n', yy___stderr  ); \
  exit( 1 ); \
  } \
 while ( 0 )

/*  default yywrap function - always treat EOF as an EOF */
#define yywrap() 1


/*  default declaration of generated scanner - a define so the user can
 * easily add parameters
 */
#define YY_DECL int yylex YY_PROTO(( void )) 
#else 
/*  c++ */
#define ECHO yy___echo()
#define YY_INPUT(buf,result,max_size) \
 if ( yy___input((char *)buf, result,max_size) < 0 ) \
     YY_FATAL_ERROR( "YY_INPUT() in flex scanner failed" );

#define YY_FATAL_ERROR(msg) yy___fatal_error(msg)
#define yywrap() yy___wrap()

#endif
/* **********************************/
/*  not to be changed */
#define YY_NULL 0
#define YY_END_OF_BUFFER_CHAR 0
/*  special action meaning "start processing a new file" */
#define YY_NEW_FILE yy___newfile 
/*  enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN
 */
#define BEGIN yy_start = 1 + 2 *

/*  action number for EOF rule of a given start state */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)



/*  % section 1 definitions go here */ 

#define INITIAL 0


#define KEYWORD_TOKEN(name, CODE) \
 { got_keyword(yylval); CODE return CcpParser::name; }

#define YY_CcpLexer_FLEX_SCANNER
#define LEX_DEFINE_BODY 1
#define LEX_DEFINE_ID 2
#define LEX_EXCLUDE 3
#define LEX_INCLUDE 4
#define LEX_NORMAL 5
#define LEX_PERCENT 6



#define yy___stderr YY_CcpLexer_ERRFILE
#define yy___text YY_CcpLexer_TEXT
#define yy___leng YY_CcpLexer_LENG
#define yy___in YY_CcpLexer_IN
#define yy___out YY_CcpLexer_OUT
#define yy___newfile \
 do \
  { \
  YY_CcpLexer_INIT_BUFFER( YY_CcpLexer_CURRENT_BUFFER, yy___in ); \
  YY_CcpLexer_LOAD_BUFFER_STATE(); \
  } \
 while ( 0 )
#if YY_CcpLexer_DEBUG != 0
#define yy___flex_debug YY_CcpLexer_DEBUG_FLAG
#endif


#ifdef YY_USE_CLASS

#define yy___echo YY_CcpLexer_ECHO
#define yy___input YY_CcpLexer_INPUT
#define yy___fatal_error YY_CcpLexer_FATAL_ERROR
#define yy___wrap YY_CcpLexer_WRAP

#endif

/*  done after the current pattern has been matched and before the
 * corresponding action - sets up yy___text
 */
#define YY_DO_BEFORE_ACTION \
 yy___text = yy_bp; \
/*  % code to fiddle yy___text and yy___leng for yymore() goes here */ \
 yy___leng = yy_cp - yy_bp; \
 yy_hold_char = *yy_cp; \
 *yy_cp = '\0'; \
 yy_c_buf_p = yy_cp;

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2

/*  return all but the first 'n' matched characters back to the input stream */
#define yyless(n) \
 do \
  { \
  /*  undo effects of setting up yy___text */ \
  *yy_cp = yy_hold_char; \
  yy_c_buf_p = yy_cp = yy_bp + n; \
  YY_DO_BEFORE_ACTION; /*  set up yy___text again */ \
  } \
 while ( 0 )

#define unput(c) yyunput( c, yy___text )



struct yy_buffer_state
    {
    YY_CcpLexer_IFILE  *yy_input_file;

    YY_CcpLexer_CHAR *yy_ch_buf;               /*  input buffer */
    YY_CcpLexer_CHAR *yy_buf_pos;      /*  current position in input buffer */

    /*  size of input buffer in bytes, not including room for EOB characters */
    int yy_buf_size;    

    /*  number of characters read into yy_ch_buf, not including EOB characters */
    int yy_n_chars;

    int yy_eof_status;          /*  whether we've seen an EOF on this buffer */
#define EOF_NOT_SEEN 0
    /*  "pending" happens when the EOF has been seen but there's still
     * some text process
     */
#define EOF_PENDING 1
#define EOF_DONE 2
    };

/*  we provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state"
 */

#ifndef YY_USE_CLASS

#if YY_CcpLexer_DEBUG != 0
int YY_CcpLexer_DEBUG_FLAG=YY_CcpLexer_DEBUG_INIT;
#endif
#define YY_CURRENT_BUFFER YY_CcpLexer_CURRENT_BUFFER
static YY_BUFFER_STATE YY_CcpLexer_CURRENT_BUFFER;
/*  yy_hold_char holds the character lost when yy___text is formed */
static YY_CcpLexer_CHAR yy_hold_char;

static int yy_n_chars;          /*  number of characters read into yy_ch_buf */

/*  GLOBAL */
YY_CcpLexer_CHAR *yy___text;
int yy___leng;

YY_CcpLexer_IFILE  *yy___in = (YY_CcpLexer_IFILE  *) 0;
YY_CcpLexer_OFILE *yy___out = (YY_CcpLexer_OFILE  *) 0;

#ifdef __cplusplus
static int yyinput YY_PROTO(( void ));
#else
static int input YY_PROTO(( void ));
#endif
/*  these variables are all declared out here so that section 3 code can
 * manipulate them
 */
/*  points to current character in buffer */
static YY_CcpLexer_CHAR *yy_c_buf_p = (YY_CcpLexer_CHAR *) 0;
static int yy_init = 1;         /*  whether we need to initialize */
static int yy_start = 0;        /*  start state number */

/*  flag which is used to allow yywrap()'s to do buffer switches
 * instead of setting up a fresh yy___in.  A bit of a hack ...
 */
static int yy_did_buffer_switch_on_eof;

static int yy_get_next_buffer YY_PROTO(( void ));
static void yyunput YY_PROTO(( YY_CcpLexer_CHAR c, YY_CcpLexer_CHAR *buf_ptr ));

#else
/*  c++ */
#ifndef YY_CcpLexer_ECHO_NOCODE
void YY_CcpLexer_CLASS::yy___echo()
{YY_CcpLexer_ECHO_CODE
}
#endif
#ifndef YY_CcpLexer_INPUT_NOCODE
int  YY_CcpLexer_CLASS::yy___input(char * buffer,int &result,int max_size)
{YY_CcpLexer_INPUT_CODE
}
#endif
#ifndef YY_CcpLexer_FATAL_ERROR_NOCODE
void YY_CcpLexer_CLASS::yy___fatal_error(const char *msg)
{YY_CcpLexer_FATAL_ERROR_CODE
}
#endif
#ifndef YY_CcpLexer_WRAP_NOCODE
int  YY_CcpLexer_CLASS::yy___wrap()
{YY_CcpLexer_WRAP_CODE
}
#endif
void YY_CcpLexer_CLASS::yy_initialize()
{
 yy___in=0;yy___out=0;yy_init = 1;
 yy_start=0;
 yy___text=0;yy___leng=0;
 YY_CcpLexer_CURRENT_BUFFER=0;
 yy_did_buffer_switch_on_eof=0;
 yy_c_buf_p=0;yy_hold_char=0;yy_n_chars=0;
#if YY_CcpLexer_DEBUG != 0
 YY_CcpLexer_DEBUG_FLAG=YY_CcpLexer_DEBUG_INIT;
#endif
}

YY_CcpLexer_CLASS::YY_CcpLexer_CLASS(YY_CcpLexer_CONSTRUCTOR_PARAM) YY_CcpLexer_CONSTRUCTOR_INIT
{yy_initialize();
 YY_CcpLexer_CONSTRUCTOR_CODE;
}
YY_CcpLexer_CLASS::~YY_CcpLexer_CLASS() 
{YY_CcpLexer_DESTRUCTOR_CODE;
 if(YY_CcpLexer_CURRENT_BUFFER)
  YY_CcpLexer_DELETE_BUFFER(YY_CcpLexer_CURRENT_BUFFER);
}

#endif


#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif

#ifndef YY_USER_INIT
#define YY_USER_INIT
#endif

/*  % data tables for the DFA go here */ 
#define YY_END_OF_BUFFER 24
typedef int yy_state_type;
static const short int yy_accept[95] =
    {   0,
        2,    2,    0,    0,    0,    0,   16,   16,    0,    0,
       21,   21,    0,    0,   24,    2,    4,    1,   22,    6,
       16,   14,   15,   21,   20,   19,   18,    7,   18,   18,
       18,   18,    2,    4,    3,    1,    6,    5,   16,   14,
       15,   21,   19,   18,    7,    7,   18,   18,   18,   18,
       18,    3,    5,   18,   18,   18,   18,   18,   18,   18,
       18,   18,   18,   18,   18,   12,   18,   18,   18,   18,
       18,   18,    8,   18,   18,   11,   18,   18,   18,   18,
       13,   18,   18,   18,   18,    9,   18,   17,   18,   18,
       18,   18,   10,    0

    } ;

static const YY_CHAR yy_ec[256] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    2,    4,    4,    4,    4,    5,    4,    4,    4,
        4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
        4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
        4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
        4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
        4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
        4,    4,    4,    4,    4,    4,    6,    4,    7,    8,

        9,   10,    4,    4,   11,    4,    4,   12,   13,   14,
       15,   16,    4,   17,   18,   19,   20,    4,    4,    4,
        4,    4,    4,    4,    4,    4,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1
    } ;

static const YY_CHAR yy_meta[21] =
    {   0,
        1,    1,    2,    3,    3,    3,    3,    3,    3,    3,
        3,    3,    3,    3,    3,    3,    3,    3,    3,    3
    } ;

static const short int yy_base[113] =
    {   0,
        0,    1,  127,  126,  125,  124,  123,  122,    6,    9,
      121,  120,   12,   31,  122,    0,  116,    0,  131,  115,
        0,  117,    0,    0,  131,  116,    0,    0,  108,  102,
        5,  106,    0,    0,    0,    0,    0,    0,    0,  112,
        0,    0,  111,    0,    0,   23,  102,  103,   94,    9,
       91,    0,    0,   97,   99,   14,   94,   96,   85,   89,
       93,   92,   83,   79,   80,    0,   85,   81,   75,   66,
       74,   69,    0,   65,   64,    0,   61,   43,   34,   33,
        0,   39,   36,   25,   34,    0,   35,    0,   19,   26,
       20,   16,    0,  131,   50,   53,   56,   59,   62,   65,

       68,   71,   74,   77,   80,   24,   83,   19,   86,   89,
       92,   95
    } ;

static const short int yy_def[113] =
    {   0,
       95,   95,   96,   96,   96,   96,   97,   97,   98,   98,
       99,   99,  100,  100,   94,  101,  102,  103,   94,  104,
      105,   94,  106,  107,   94,   94,  108,  109,  108,  108,
      108,  108,  101,  102,  110,  103,  104,  111,  105,   94,
      106,  107,   94,  108,  112,  109,  108,  108,  108,  108,
      108,  110,  111,  108,  108,  108,  108,  108,  108,  108,
      108,  108,  108,  108,  108,  108,  108,  108,  108,  108,
      108,  108,  108,  108,  108,  108,  108,  108,  108,  108,
      108,  108,  108,  108,  108,  108,  108,  108,  108,  108,
      108,  108,  108,    0,   94,   94,   94,   94,   94,   94,

       94,   94,   94,   94,   94,   94,   94,   94,   94,   94,
       94,   94
    } ;

static const short int yy_nxt[152] =
    {   0,
       45,   45,   17,   17,   18,   18,   19,   22,   20,   19,
       22,   20,   25,   26,   20,   57,   28,   49,   50,   29,
       30,   44,   31,   45,   45,   62,   41,   58,   63,   93,
       32,   25,   26,   20,   92,   28,   91,   90,   29,   30,
       89,   31,   88,   87,   86,   85,   84,   83,   82,   32,
       16,   16,   16,   19,   19,   19,   21,   21,   21,   23,
       23,   23,   24,   24,   24,   27,   27,   27,   33,   81,
       33,   34,   80,   34,   36,   79,   36,   37,   78,   37,
       39,   77,   39,   42,   76,   42,   46,   75,   46,   52,
       74,   52,   53,   73,   53,   45,   72,   45,   71,   70,

       69,   68,   67,   66,   65,   64,   61,   60,   59,   56,
       55,   54,   43,   40,   51,   48,   47,   43,   40,   38,
       35,   94,   20,   20,   20,   20,   20,   20,   20,   20,
       15,   94,   94,   94,   94,   94,   94,   94,   94,   94,
       94,   94,   94,   94,   94,   94,   94,   94,   94,   94,
       94
    } ;

static const short int yy_chk[152] =
    {   0,
       28,   28,    1,    2,    1,    2,    9,    9,    9,   10,
       10,   10,   13,   13,   13,   50,   13,   31,   31,   13,
       13,  108,   13,   46,   46,   56,  106,   50,   56,   92,
       13,   14,   14,   14,   91,   14,   90,   89,   14,   14,
       87,   14,   85,   84,   83,   82,   80,   79,   78,   14,
       95,   95,   95,   96,   96,   96,   97,   97,   97,   98,
       98,   98,   99,   99,   99,  100,  100,  100,  101,   77,
      101,  102,   75,  102,  103,   74,  103,  104,   72,  104,
      105,   71,  105,  107,   70,  107,  109,   69,  109,  110,
       68,  110,  111,   67,  111,  112,   65,  112,   64,   63,

       62,   61,   60,   59,   58,   57,   55,   54,   51,   49,
       48,   47,   43,   40,   32,   30,   29,   26,   22,   20,
       17,   15,   12,   11,    8,    7,    6,    5,    4,    3,
       94,   94,   94,   94,   94,   94,   94,   94,   94,   94,
       94,   94,   94,   94,   94,   94,   94,   94,   94,   94,
       94
    } ;

static yy_state_type yy_last_accepting_state;
static YY_CHAR *yy_last_accepting_cpos;

#if YY_CcpLexer_DEBUG != 0
static const short int yy_rule_linenum[23] =
    {   0,
      117,  123,  134,  140,  151,  157,  169,  172,  173,  174,
      175,  176,  178,  179,  181,  182,  184,  185,  186,  189,
      191,  192
    } ;

#endif
/*  the intent behind this definition is that it'll catch
 * any uses of REJECT which flex missed
 */
#define REJECT reject_used_but_not_detected
#define yymore() yymore_used_but_not_detected
#define YY_MORE_ADJ 0

#ifndef YY_USE_CLASS
static yy_state_type yy_get_previous_state YY_PROTO(( void ));
static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
#else
#define yy_get_previous_state() ((yy_state_type)(yy_get_previous_state_()))
#define yy_try_NUL_trans(c) ((yy_state_type)(yy_try_NUL_trans_(c)))
#endif

#ifndef YY_USE_CLASS
#ifdef YY_CcpLexer_LEX_DEFINED
YY_CcpLexer_LEX_RETURN YY_CcpLexer_LEX ( YY_CcpLexer_LEX_PARAM )
YY_CcpLexer_LEX_PARAM_DEF
#else
YY_DECL
#endif
#else
YY_CcpLexer_LEX_RETURN YY_CcpLexer_CLASS::YY_CcpLexer_LEX ( YY_CcpLexer_LEX_PARAM)

#endif
    {
    yy_state_type yy_current_state;
    YY_CcpLexer_CHAR *yy_cp, *yy_bp;
    int yy_act;

/*  % user's declarations go here */ 

/*  % end of prolog */ 


    if ( yy_init )
 {
  
  {
  YY_USER_INIT;
  }
 if ( ! yy_start )
     yy_start = 1;       /*  first start state */

 if ( ! yy___in )
     yy___in = YY_CcpLexer_IFILE_DEFAULT;

 if ( ! yy___out )
     yy___out = YY_CcpLexer_OFILE_DEFAULT;

 if ( YY_CcpLexer_CURRENT_BUFFER )
     YY_CcpLexer_INIT_BUFFER( YY_CcpLexer_CURRENT_BUFFER, yy___in );
 else
     YY_CcpLexer_CURRENT_BUFFER = YY_CcpLexer_CREATE_BUFFER( yy___in, YY_BUF_SIZE );

 YY_CcpLexer_LOAD_BUFFER_STATE();
 yy_init=0;
 }

    while ( 1 )         /*  loops until end-of-file is reached */
 {
/*  % yymore()-related code goes here */ 

 yy_cp = yy_c_buf_p;

 /*  support of yy___text */
 *yy_cp = yy_hold_char;

 /*  yy_bp points to the position in yy_ch_buf of the start of the
	 * current run.
	 */
 yy_bp = yy_cp;

/*  % code to set up and find next match goes here */ 
 yy_current_state = yy_start;
yy_match:
 do
     {
     YY_CHAR yy_c = yy_ec[*yy_cp];
     if ( yy_accept[yy_current_state] )
  {
  yy_last_accepting_state = yy_current_state;
  yy_last_accepting_cpos = yy_cp;
  }
     while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
  {
  yy_current_state = yy_def[yy_current_state];
  if ( yy_current_state >= 95 )
      yy_c = yy_meta[yy_c];
  }
     yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
     ++yy_cp;
     }
 while ( yy_current_state != 94 );
 yy_cp = yy_last_accepting_cpos;
 yy_current_state = yy_last_accepting_state;


yy_find_action:
/*  % code to find the action number goes here */ 
 yy_act = yy_accept[yy_current_state];


 YY_DO_BEFORE_ACTION;
 YY_USER_ACTION;

do_action:      /*  this label is used only to access EOF actions */
#if YY_CcpLexer_DEBUG != 0
 if ( yy___flex_debug )
  {
  if ( yy_act == 0 )
#ifndef YY_CcpLexer_IOSTREAM
   fprintf( yy___stderr , "--scanner backtracking\n" );
#else
   yy___stderr <<"--scanner backtracking"<<endl;
#endif
  else if ( yy_act < YY_END_OF_BUFFER -1 )
#ifndef YY_CcpLexer_IOSTREAM
   fprintf( yy___stderr , 
    "--accepting rule at line %d (\"%s\")\n",
    yy_rule_linenum[yy_act], yy___text );
#else
   yy___stderr <<"--accepting rule at line "
                          <<(int)yy_rule_linenum[yy_act]
                          <<" (\""<<(char *)yy___text<<"\")"<<endl;
#endif
  else if ( yy_act == YY_END_OF_BUFFER -1 )
#ifndef YY_CcpLexer_IOSTREAM
   fprintf( yy___stderr , 
    "--accepting default rule (\"%s\")\n",
    yy___text );
#else
   yy___stderr <<"--accepting default rule"
                          <<" (\""<<(char *)yy___text<<"\")"<<endl;
#endif
  else if ( yy_act == YY_END_OF_BUFFER )
#ifndef YY_CcpLexer_IOSTREAM
   fprintf( yy___stderr , "--(end of buffer or a NUL)\n" );
#else
   yy___stderr <<"--(end of buffer or a NUL)"<<endl;
#endif
  else
#ifndef YY_CcpLexer_IOSTREAM
   fprintf( yy___stderr , "--EOF\n" );
#else
   yy___stderr <<"--EOF"<<endl;
#endif
  }
#endif
 switch ( yy_act )
     {
/*  % actions go here */ 
     case 0: /*  must backtrack */
     /*  undo the effects of YY_DO_BEFORE_ACTION */
     *yy_cp = yy_hold_char;
     yy_cp = yy_last_accepting_cpos;
     yy_current_state = yy_last_accepting_state;
     goto yy_find_action;

case 1:

{    //  Read, buffer and reject non-blank line 1.
         _context.buffer_line(yytext, yyleng, false);
         if (!expand_line())
          yyless(1);
         BEGIN(LEX_PERCENT);
        }
 YY_BREAK
case 2:

{    //  Read, buffer and reject non-blank line 1.
         _context.buffer_line(yytext, yyleng, false);
         if (!expand_line())
          yyless(0);
         BEGIN(LEX_NORMAL);
         if (!_context.text() || !*_context.text())
         {
          yylval.string() = 0;
          CONDMSG(CcpReader::debug_lex(), _context.line() << " BLANK LINE");
          return CcpParser::Line;
         }           }
 YY_BREAK
case 3:

{    //  Read blank line 1 and then buffer and reject line 2.
         _context.buffer_line(&yytext[1], yyleng-1, true);
         if (!expand_line())
          yyless(2);
         BEGIN(LEX_PERCENT);
        }
 YY_BREAK
case 4:

{    //  Read blank line 1 and then buffer and reject line 2.
         _context.buffer_line(&yytext[1], yyleng-1, true);
         if (!expand_line())
          yyless(1);
         BEGIN(LEX_NORMAL);
         if (!_context.text() || !*_context.text())
         {
          yylval.string() = 0;
          CONDMSG(CcpReader::debug_lex(), _context.line() << " BLANK LINE");
          return CcpParser::Line;
         }           }
 YY_BREAK
case 5:

{    //  Read and buffer any subsequent line.
         _context.buffer_line(&yytext[1], yyleng-1, false);
         if (!expand_line())
          yyless(2);
         BEGIN(LEX_PERCENT);
        }
 YY_BREAK
case 6:

{    //  Read and buffer any subsequent line.
         _context.buffer_line(&yytext[1], yyleng-1, false);
         if (!expand_line())
          yyless(1);
         BEGIN(LEX_NORMAL);
         if (!_context.text() || !*_context.text())
         {
          yylval.string() = 0;
          CONDMSG(CcpReader::debug_lex(), _context.line() << " BLANK LINE");
          return CcpParser::Line;
         }         
        }
 YY_BREAK
case 7:

{ CONDMSG(CcpReader::debug_lex(),
         _context.line() << " %COMMENT \" " << text() << "\""); }
 YY_BREAK
case 8:

KEYWORD_TOKEN(DEFINE,;)
 YY_BREAK
case 9:

KEYWORD_TOKEN(ENDDEFINE,;)
 YY_BREAK
case 10:

KEYWORD_TOKEN(IMPLEMENTATION,;)
 YY_BREAK
case 11:

KEYWORD_TOKEN(IMPORT,;)
 YY_BREAK
case 12:

KEYWORD_TOKEN(TEST,;)
 YY_BREAK
case 13:

{ got_keyword(yylval); BEGIN(LEX_INCLUDE); }
 YY_BREAK
case 14:

{ advance(yyleng); CONDMSG(CcpReader::debug_lex(),
         _context.line() << " SPACING \"" << text() << "\""); }
 YY_BREAK
case 15:

{ got_include(); }
 YY_BREAK
case 16:

{}
 YY_BREAK
case 17:

KEYWORD_TOKEN(INTERFACE,;)
 YY_BREAK
case 18:

{ got_line(yylval); return CcpParser::String; }
 YY_BREAK
case 19:

{ advance(yyleng); CONDMSG(CcpReader::debug_lex(),
         _context.line() << " %SPACING \"" << text() << "\""); }
 YY_BREAK
case 20:

{ advance(yyleng); CONDMSG(CcpReader::debug_lex(),
         _context.line() << " %. \"" << text() << "\"");}
 YY_BREAK
case 21:

{ got_line(yylval); return CcpParser::Line; }
 YY_BREAK
case 22:

{ advance(yyleng); CONDMSG(CcpReader::debug_lex(),
         _context.line() << " . \"" << text() << "\"");}
 YY_BREAK
case 23:

ECHO;
 YY_BREAK
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(LEX_DEFINE_BODY):
case YY_STATE_EOF(LEX_DEFINE_ID):
case YY_STATE_EOF(LEX_EXCLUDE):
case YY_STATE_EOF(LEX_INCLUDE):
case YY_STATE_EOF(LEX_NORMAL):
case YY_STATE_EOF(LEX_PERCENT):
    yyterminate();


     case YY_END_OF_BUFFER:
  {
  /*  amount of text matched not including the EOB char */
  int yy_amount_of_matched_text = yy_cp - yy___text - 1;

  /*  undo the effects of YY_DO_BEFORE_ACTION */
  *yy_cp = yy_hold_char;

  /*  note that here we test for yy_c_buf_p "<=" to the position
		 * of the first EOB in the buffer, since yy_c_buf_p will
		 * already have been incremented past the NUL character
		 * (since all states make transitions on EOB to the end-
		 * of-buffer state).  Contrast this with the test in yyinput().
		 */
  if ( yy_c_buf_p <= &YY_CcpLexer_CURRENT_BUFFER->yy_ch_buf[yy_n_chars] )
      /*  this was really a NUL */
      {
      yy_state_type yy_next_state;

      yy_c_buf_p = yy___text + yy_amount_of_matched_text;

      yy_current_state = yy_get_previous_state();

      /*  okay, we're now positioned to make the
		     * NUL transition.  We couldn't have
		     * yy_get_previous_state() go ahead and do it
		     * for us because it doesn't know how to deal
		     * with the possibility of jamming (and we
		     * don't want to build jamming into it because
		     * then it will run more slowly)
		     */

      yy_next_state = yy_try_NUL_trans( yy_current_state );

      yy_bp = yy___text + YY_MORE_ADJ;

      if ( yy_next_state )
   {
   /*  consume the NUL */
   yy_cp = ++yy_c_buf_p;
   yy_current_state = yy_next_state;
   goto yy_match;
   }

      else
   {
/*  % code to do backtracking for compressed tables and set up yy_cp goes here */ 
       yy_cp = yy_last_accepting_cpos;
       yy_current_state = yy_last_accepting_state;

   goto yy_find_action;
   }
      }

  else switch ( yy_get_next_buffer() )
      {
      case EOB_ACT_END_OF_FILE:
   {
   yy_did_buffer_switch_on_eof = 0;

   if ( yywrap() )
       {
       /*  note: because we've taken care in
			     * yy_get_next_buffer() to have set up yy___text,
			     * we can now set up yy_c_buf_p so that if some
			     * total hoser (like flex itself) wants
			     * to call the scanner after we return the
			     * YY_NULL, it'll still work - another YY_NULL
			     * will get returned.
			     */
       yy_c_buf_p = yy___text + YY_MORE_ADJ;

       yy_act = YY_STATE_EOF((yy_start - 1) / 2);
       goto do_action;
       }

   else
       {
       if ( ! yy_did_buffer_switch_on_eof )
    YY_NEW_FILE;
       }
   }
   break;

      case EOB_ACT_CONTINUE_SCAN:
   yy_c_buf_p = yy___text + yy_amount_of_matched_text;

   yy_current_state = yy_get_previous_state();

   yy_cp = yy_c_buf_p;
   yy_bp = yy___text + YY_MORE_ADJ;
   goto yy_match;

      case EOB_ACT_LAST_MATCH:
   yy_c_buf_p =
       &YY_CcpLexer_CURRENT_BUFFER->yy_ch_buf[yy_n_chars];

   yy_current_state = yy_get_previous_state();

   yy_cp = yy_c_buf_p;
   yy_bp = yy___text + YY_MORE_ADJ;
   goto yy_find_action;
      }
  break;
  }

     default:
#if YY_CcpLexer_DEBUG != 0
#ifndef YY_CcpLexer_IOSTREAM
  fprintf(yy___stderr , "action # %d\n", yy_act );
#else
  yy___stderr <<"action # "<<(int)yy_act<<endl;
#endif
#endif
  YY_FATAL_ERROR(
   "fatal flex scanner internal error--no action found" );
     }
 }
 yyterminate();/*  avoid the no return value error message on MS-C7/dos */
    }


/*  yy_get_next_buffer - try to read in a new buffer
 *
 * synopsis
 *     int yy_get_next_buffer();
 *     
 * returns a code representing an action
 *     EOB_ACT_LAST_MATCH - 
 *     EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *     EOB_ACT_END_OF_FILE - end of file
 */
#ifndef YY_USE_CLASS
static int yy_get_next_buffer()
#else
int YY_CcpLexer_CLASS::yy_get_next_buffer()
#endif
    {
    YY_CcpLexer_CHAR *dest = YY_CcpLexer_CURRENT_BUFFER->yy_ch_buf;
    YY_CcpLexer_CHAR *source = yy___text - 1; /*  copy prev. char, too */
    int number_to_move, i;
    int ret_val;

    if ( yy_c_buf_p > &YY_CcpLexer_CURRENT_BUFFER->yy_ch_buf[yy_n_chars + 1] )
 YY_FATAL_ERROR(
  "fatal flex scanner internal error--end of buffer missed" );

    /*  try to read more data */

    /*  first move last chars to start of buffer */
    number_to_move = yy_c_buf_p - yy___text;

    for ( i = 0; i < number_to_move; ++i )
 *(dest++) = *(source++);

    if ( YY_CcpLexer_CURRENT_BUFFER->yy_eof_status != EOF_NOT_SEEN )
 /*  don't do the read, it's not guaranteed to return an EOF,
	 * just force an EOF
	 */
 yy_n_chars = 0;

    else
 {
 int num_to_read = YY_CcpLexer_CURRENT_BUFFER->yy_buf_size - number_to_move - 1;

 if ( num_to_read > YY_READ_BUF_SIZE )
     num_to_read = YY_READ_BUF_SIZE;

 else if ( num_to_read <= 0 )
     YY_FATAL_ERROR( "fatal error - scanner input buffer overflow" );

 /*  read in more data */
 YY_INPUT( (&YY_CcpLexer_CURRENT_BUFFER->yy_ch_buf[number_to_move]),
    yy_n_chars, num_to_read );
 }

    if ( yy_n_chars == 0 )
 {
 if ( number_to_move - YY_MORE_ADJ == 1 )
     {
     ret_val = EOB_ACT_END_OF_FILE;
     YY_CcpLexer_CURRENT_BUFFER->yy_eof_status = EOF_DONE;
     }

 else
     {
     ret_val = EOB_ACT_LAST_MATCH;
     YY_CcpLexer_CURRENT_BUFFER->yy_eof_status = EOF_PENDING;
     }
 }

    else
 ret_val = EOB_ACT_CONTINUE_SCAN;

    yy_n_chars += number_to_move;
    YY_CcpLexer_CURRENT_BUFFER->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
    YY_CcpLexer_CURRENT_BUFFER->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;

    /*  yy___text begins at the second character in yy_ch_buf; the first
     * character is the one which preceded it before reading in the latest
     * buffer; it needs to be kept around in case it's a newline, so
     * yy_get_previous_state() will have with '^' rules active
     */

    yy___text = &YY_CcpLexer_CURRENT_BUFFER->yy_ch_buf[1];

    return ( ret_val );
    }


/*  yy_get_previous_state - get the state just before the EOB char was reached
 *
 * synopsis
 *     yy_state_type yy_get_previous_state();
 */

#ifndef YY_USE_CLASS
static yy_state_type yy_get_previous_state()
#else
long YY_CcpLexer_CLASS::yy_get_previous_state_()
#endif
    {
    yy_state_type yy_current_state;
    YY_CcpLexer_CHAR *yy_cp;

/*  % code to get the start state into yy_current_state goes here */ 
    yy_current_state = yy_start;


    for ( yy_cp = yy___text + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
 {
/*  % code to find the next state goes here */ 
 YY_CHAR yy_c = (*yy_cp ? yy_ec[*yy_cp] : 1);
 if ( yy_accept[yy_current_state] )
     {
     yy_last_accepting_state = yy_current_state;
     yy_last_accepting_cpos = yy_cp;
     }
 while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
     {
     yy_current_state = yy_def[yy_current_state];
     if ( yy_current_state >= 95 )
  yy_c = yy_meta[yy_c];
     }
 yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];

 }

#ifndef YY_USE_CLASS
    return ( yy_current_state );
#else
    return (long)( yy_current_state );
#endif
    }


/*  yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *     next_state = yy_try_NUL_trans( current_state );
 */

#ifndef YY_USE_CLASS
#ifdef YY_USE_PROTOS
static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )
#else
static yy_state_type yy_try_NUL_trans( yy_current_state )
register yy_state_type yy_current_state;
#endif
#else
long YY_CcpLexer_CLASS::yy_try_NUL_trans_(long yy_current_state_)
#endif

    {
#ifndef YY_USE_CLASS
#else
    yy_state_type yy_current_state=(yy_state_type)yy_current_state_;
#endif
    int yy_is_jam;
/*  % code to find the next state, and perhaps do backtracking, goes here */ 
    YY_CHAR *yy_cp = yy_c_buf_p;

    YY_CHAR yy_c = 1;
    if ( yy_accept[yy_current_state] )
 {
 yy_last_accepting_state = yy_current_state;
 yy_last_accepting_cpos = yy_cp;
 }
    while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
 {
 yy_current_state = yy_def[yy_current_state];
 if ( yy_current_state >= 95 )
     yy_c = yy_meta[yy_c];
 }
    yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
    yy_is_jam = (yy_current_state == 94);


#ifndef YY_USE_CLASS
    return ( yy_is_jam ? 0 : yy_current_state );
#else
    return (long)( yy_is_jam ? 0 : yy_current_state );
#endif
    }

#ifndef YY_USE_CLASS
#ifdef YY_USE_PROTOS
static void yyunput( YY_CcpLexer_CHAR c, YY_CcpLexer_CHAR *yy_bp )
#else
static void yyunput( c, yy_bp )
YY_CcpLexer_CHAR c;
register YY_CcpLexer_CHAR *yy_bp;
#endif
#else
void YY_CcpLexer_CLASS::yyunput( YY_CcpLexer_CHAR c, YY_CcpLexer_CHAR *yy_bp )
#endif

    {
    YY_CcpLexer_CHAR *yy_cp = yy_c_buf_p;

    /*  undo effects of setting up yy___text */
    *yy_cp = yy_hold_char;

    if ( yy_cp < YY_CcpLexer_CURRENT_BUFFER->yy_ch_buf + 2 )
 { /*  need to shift things up to make room */
 int number_to_move = yy_n_chars + 2; /*  +2 for EOB chars */
 YY_CcpLexer_CHAR *dest =
     &YY_CcpLexer_CURRENT_BUFFER->yy_ch_buf[YY_CcpLexer_CURRENT_BUFFER->yy_buf_size + 2];
 YY_CcpLexer_CHAR *source =
     &YY_CcpLexer_CURRENT_BUFFER->yy_ch_buf[number_to_move];

 while ( source > YY_CcpLexer_CURRENT_BUFFER->yy_ch_buf )
     *--dest = *--source;

 yy_cp += dest - source;
 yy_bp += dest - source;
 yy_n_chars = YY_CcpLexer_CURRENT_BUFFER->yy_buf_size;

 if ( yy_cp < YY_CcpLexer_CURRENT_BUFFER->yy_ch_buf + 2 )
     YY_FATAL_ERROR( "flex scanner push-back overflow" );
 }

    if ( yy_cp > yy_bp && yy_cp[-1] == '\n' )
 yy_cp[-2] = '\n';

    *--yy_cp = c;

    /*  note: the formal parameter *must* be called "yy_bp" for this
     *       macro to now work correctly
     */
    YY_DO_BEFORE_ACTION; /*  set up yy___text again */
    }

#ifndef YY_USE_CLASS
#ifdef __cplusplus
static int yyinput()
#else
static int input()
#endif
#else
int YY_CcpLexer_CLASS::input()
#endif
    {
    int c;
    YY_CcpLexer_CHAR *yy_cp = yy_c_buf_p;

    *yy_cp = yy_hold_char;

    if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
 {
 /*  yy_c_buf_p now points to the character we want to return.
	 * If this occurs *before* the EOB characters, then it's a
	 * valid NUL; if not, then we've hit the end of the buffer.
	 */
 if ( yy_c_buf_p < &YY_CcpLexer_CURRENT_BUFFER->yy_ch_buf[yy_n_chars] )
     /*  this was really a NUL */
     *yy_c_buf_p = '\0';

 else
     { /*  need more input */
     yy___text = yy_c_buf_p;
     ++yy_c_buf_p;

     switch ( yy_get_next_buffer() )
  {
  case EOB_ACT_END_OF_FILE:
      {
      if ( yywrap() )
   {
   yy_c_buf_p = yy___text + YY_MORE_ADJ;
   return ( EOF );
   }

      YY_NEW_FILE;
#ifndef YY_USE_CLASS
#ifdef __cplusplus
      return ( yyinput() );
#else
      return ( input() );
#endif
#else
      return ( input() );
#endif
      }
      break;

  case EOB_ACT_CONTINUE_SCAN:
      yy_c_buf_p = yy___text + YY_MORE_ADJ;
      break;

  case EOB_ACT_LAST_MATCH:
#ifndef YY_USE_CLASS
#ifdef __cplusplus
      YY_FATAL_ERROR( "unexpected last match in yyinput()" );
#else
      YY_FATAL_ERROR( "unexpected last match in input()" );
#endif
#else
      YY_FATAL_ERROR( "unexpected last match in YY_CcpLexer_CLASS::input()" );
#endif
  }
     }
 }

    c = *yy_c_buf_p;
    yy_hold_char = *++yy_c_buf_p;

    return ( c );
    }


#ifndef YY_USE_CLASS
#ifdef YY_USE_PROTOS
void YY_CcpLexer_RESTART( YY_CcpLexer_IFILE  *input_file )
#else
void YY_CcpLexer_RESTART( input_file )
YY_CcpLexer_IFILE  *input_file;
#endif
#else
void YY_CcpLexer_CLASS::YY_CcpLexer_RESTART ( YY_CcpLexer_IFILE  *input_file )
#endif

    {
    YY_CcpLexer_INIT_BUFFER( YY_CcpLexer_CURRENT_BUFFER, input_file );
    YY_CcpLexer_LOAD_BUFFER_STATE();
    }


#ifndef YY_USE_CLASS
#ifdef YY_USE_PROTOS
void YY_CcpLexer_SWITCH_TO_BUFFER( YY_BUFFER_STATE new_buffer )
#else
void YY_CcpLexer_SWITCH_TO_BUFFER( new_buffer )
YY_BUFFER_STATE new_buffer;
#endif
#else
void YY_CcpLexer_CLASS::YY_CcpLexer_SWITCH_TO_BUFFER( YY_BUFFER_STATE new_buffer )
#endif

    {
    if ( YY_CcpLexer_CURRENT_BUFFER == new_buffer )
 return;

    if ( YY_CcpLexer_CURRENT_BUFFER )
 {
 /*  flush out information for old buffer */
 *yy_c_buf_p = yy_hold_char;
 YY_CcpLexer_CURRENT_BUFFER->yy_buf_pos = yy_c_buf_p;
 YY_CcpLexer_CURRENT_BUFFER->yy_n_chars = yy_n_chars;
 }

    YY_CcpLexer_CURRENT_BUFFER = new_buffer;
    YY_CcpLexer_LOAD_BUFFER_STATE();

    /*  we don't actually know whether we did this switch during
     * EOF (yywrap()) processing, but the only time this flag
     * is looked at is after yywrap() is called, so it's safe
     * to go ahead and always set it.
     */
    yy_did_buffer_switch_on_eof = 1;
    }


#ifndef YY_USE_CLASS
#ifdef YY_USE_PROTOS
void YY_CcpLexer_LOAD_BUFFER_STATE( void )
#else
void YY_CcpLexer_LOAD_BUFFER_STATE()
#endif
#else
void YY_CcpLexer_CLASS::YY_CcpLexer_LOAD_BUFFER_STATE(  )
#endif

    {
    yy_n_chars = YY_CcpLexer_CURRENT_BUFFER->yy_n_chars;
    yy___text = yy_c_buf_p = YY_CcpLexer_CURRENT_BUFFER->yy_buf_pos;
    yy___in = YY_CcpLexer_CURRENT_BUFFER->yy_input_file;
    yy_hold_char = *yy_c_buf_p;
    }


#ifndef YY_USE_CLASS
#ifdef YY_USE_PROTOS
YY_BUFFER_STATE YY_CcpLexer_CREATE_BUFFER( YY_CcpLexer_IFILE  *file, int size )
#else
YY_BUFFER_STATE YY_CcpLexer_CREATE_BUFFER( file, size )
YY_CcpLexer_IFILE  *file;
int size;
#endif
#else
YY_BUFFER_STATE YY_CcpLexer_CLASS::YY_CcpLexer_CREATE_BUFFER( YY_CcpLexer_IFILE  *file, int size )
#endif

    {
    YY_BUFFER_STATE b;

    b = (YY_BUFFER_STATE) malloc( sizeof( struct yy_buffer_state ) );

    if ( ! b )
 YY_FATAL_ERROR( "out of dynamic memory in YY_CcpLexer_CREATE_BUFFER()" );

    b->yy_buf_size = size;

    /*  yy_ch_buf has to be 2 characters longer than the size given because
     * we need to put in 2 end-of-buffer characters.
     */
    b->yy_ch_buf = (YY_CcpLexer_CHAR *) malloc( (unsigned) (b->yy_buf_size + 2) );

    if ( ! b->yy_ch_buf )
 YY_FATAL_ERROR( "out of dynamic memory in YY_CcpLexer_CREATE_BUFFER()" );

    YY_CcpLexer_INIT_BUFFER( b, file );

    return ( b );
    }


#ifndef YY_USE_CLASS
#ifdef YY_USE_PROTOS
void YY_CcpLexer_DELETE_BUFFER( YY_BUFFER_STATE b )
#else
void YY_CcpLexer_DELETE_BUFFER( b )
YY_BUFFER_STATE b;
#endif
#else
void YY_CcpLexer_CLASS::YY_CcpLexer_DELETE_BUFFER( YY_BUFFER_STATE b )
#endif

    {
    if ( b == YY_CcpLexer_CURRENT_BUFFER )
 YY_CcpLexer_CURRENT_BUFFER = (YY_BUFFER_STATE) 0;

    free( (char *) b->yy_ch_buf );
    free( (char *) b );
    }


#ifndef YY_USE_CLASS
#ifdef YY_USE_PROTOS
void YY_CcpLexer_INIT_BUFFER( YY_BUFFER_STATE b, YY_CcpLexer_IFILE  *file )
#else
void YY_CcpLexer_INIT_BUFFER( b, file )
YY_BUFFER_STATE b;
YY_CcpLexer_IFILE  *file;
#endif
#else
void YY_CcpLexer_CLASS::YY_CcpLexer_INIT_BUFFER( YY_BUFFER_STATE b, YY_CcpLexer_IFILE  *file)
#endif

    {
    b->yy_input_file = file;

    /*  we put in the '\n' and start reading from [1] so that an
     * initial match-at-newline will be true.
     */

    b->yy_ch_buf[0] = '\n';
    b->yy_n_chars = 1;

    /*  we always need two end-of-buffer characters.  The first causes
     * a transition to the end-of-buffer state.  The second causes
     * a jam in that state.
     */
    b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
    b->yy_ch_buf[2] = YY_END_OF_BUFFER_CHAR;

    b->yy_buf_pos = &b->yy_ch_buf[1];

    b->yy_eof_status = EOF_NOT_SEEN;
    }


#ifdef ECHO
#undef ECHO
#endif

TYPEINFO_SINGLE(CcpLexer, PrimPrint)

#include <Ccp/CcpIncludeAll.h>
#include <cctype>
#include <climits>

// 
// 	Generate a diagnostic using msg to explain a problem with respect to the source context.
// 
void CcpLexer::diagnostic(const char *msg)
{
 std::ostrstream s;
 message(s, msg);
 s << std::ends;
 DIAMSG(s.str());
 delete s.str();
}

// 
// 	Generate an error diagnostic using msg to explain a problem with respect to the source context.
// 
void CcpLexer::error(const char *msg)
{
 std::ostrstream s;
 message(s, msg);
 s << std::ends;
 ERRMSG(s.str());
 delete s.str();
}

// 
// 	Return true if new input line got expanded and so is available for reread.
// 
bool CcpLexer::expand_line()
{
 const unsigned char *pBegin = 0;
 const unsigned char *pEnd = 0;
 for (const unsigned char *p = _context.text(); *p; p++)
 {
  if ((*p == '$') && (*(p+1) == '{'))
   pBegin = p;
  else if (pBegin && (*p == '}'))
  {
   pEnd = p;
   break;
  }
 }
 if (!pBegin)
  return false;
 if (!pEnd)
 {
  error("unclosed macro instantiation");
  return false;
 }
 const PrimIdHandle defineName((const char *)(pBegin+2), pEnd - (pBegin+2));
 const CcpDefine *aDefine = _defines.find(*defineName);
 if (!aDefine)
 {
  error("undefined macro instantiation");
  return false;
 }
 std::strstream *s = new std::strstream;
 s->write((const char *)_context.text(), pBegin - _context.text());
 bool firstOutput = true; 
 for (PrimTextIterator q(aDefine->text()); q; ++q, firstOutput = false)
 {
  if (!firstOutput)
   *s << "\n";
  *s << *q;
 }
 *s << (const char *)(pEnd+1) << std::ends;
 _context.push(*PrimStringHandle(aDefine->id().str()), YY_CURRENT_BUFFER);
 yy_switch_to_buffer(yy_create_buffer(s, YY_BUF_SIZE));
 BEGIN(INITIAL);
 return true;
}

// 
// 	Establish aName as the new source file.
// 
void CcpLexer::got_include()
{
 CONDMSG(CcpReader::debug_lex(), _context.line() << " INCLUDE \"" << text() << "\"");
 std::ifstream *aStream = 0;
 for (PrimTextIterator p1(CcpReader::include_paths()); p1; ++p1)
 {
  unsigned int len = strlen(p1->str()) + 1 + yyleng;
  if (!set_string_buffer_capacity(len + 1))
   return;
  strcpy((char *)_string_buffer.get(), p1->str());
  strcat((char *)_string_buffer.get(), "/");
  strcat((char *)_string_buffer.get(), text());
  aStream = new std::ifstream((char *)_string_buffer.get());
  if (!aStream)
   ;
  else if (!*aStream)
  {
   delete aStream;
   aStream = 0;
  }
  else
   break;
 }
 if (!aStream || !*aStream)
 {
  ERRMSG(*this << " failed to open any file for " << c_string(text()));
  BEGIN(LEX_EXCLUDE);
 }
 else
 {
  _context.push(*PrimStringHandle((char *)_string_buffer.get()), YY_CURRENT_BUFFER);
  yy_switch_to_buffer(yy_create_buffer(aStream, YY_BUF_SIZE));
  BEGIN(INITIAL);
 }
}

// 
// 	Configure the lexer to reflect successful parsing of a keyword.
// 
void CcpLexer::got_keyword(CcpParserValue& yylval)
{
 advance(yyleng);
 yylval.number() = _context.line();
 CONDMSG(CcpReader::debug_lex(), _context.line() << " KEYWORD \"" << text() << "\"");
}

// 
// 	Configure the lexer to reflect successful parsing of a line.
// 
void CcpLexer::got_line(CcpParserValue& yylval)
{
 advance(yyleng);
 yylval.string() = text();
 CONDMSG(CcpReader::debug_lex(), _context.line() << " LINE " << yylval.string());
}

// 
// 	Configure the lexer to reflect successful parsing of a character token.
// 
void CcpLexer::got_token()
{
 advance(yyleng);
 CONDMSG(CcpReader::debug_lex(), _context.line() << " TOKEN \"" << char(yytext[0]) << "\"");
}

// 
// 	Set the capacity of the string buffer to at least aCapacity, returning true if successful.
// 
bool CcpLexer::set_string_buffer_capacity(unsigned int aCapacity)
{
 if (_string_buffer_capacity < aCapacity)
 {
  if (aCapacity <= 256)
   aCapacity = 257;
  else if (aCapacity <= 1024)
   aCapacity = 1025;
  else if (aCapacity <= 4096)
   aCapacity = 4097;
  _string_buffer.reset(new unsigned char[aCapacity]);
  if (_string_buffer)
   _string_buffer_capacity = aCapacity;
  else
  {
   _string_buffer_capacity = 0;
   ERRMSG(*this << "Failed to allocate mermory for " << aCapacity << " character string buffer.");
  }
 }
 return _string_buffer != 0;
}

// 
// 	Generate a warning diagnostic using msg to explain a problem with respect to the source context.
// 
void CcpLexer::warning(const char *msg)
{
 std::ostrstream s;
 message(s, msg);
 s << std::ends;
 WRNMSG(s.str());
 delete s.str();
}

// 
// 	Restore the previous source file reading context from the stack.
// 
int CcpLexer::yywrap()
{
 CONDMSG(CcpReader::debug_lex(), _context.line() << " End of file " << c_string(file()));
 std::istream *deadStream = yyin;
 struct yy_buffer_state *deadBuffer = YY_CURRENT_BUFFER;
 if (!_context.pop())
  return 1;
 yy_switch_to_buffer(_context.buffer());
 delete deadStream;
 yy_delete_buffer(deadBuffer);
 BEGIN(LEX_EXCLUDE);
 return 0;
}
