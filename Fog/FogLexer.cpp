#define YY_CHAR char
/* A lexical scanner generated by flex */
/*  scanner skeleton version:
    $Header: /flex_pp/flexskel.cc 3     2/09/98 3:48p Willink $
*/
/* MODIFIED FOR C++ CLASS BY Alain Coetmeur: coetmeur(at)icdc.fr */
/* Note that (at) mean the 'at' symbol that I cannot write */
/* because it is expanded to the class name */
/* made at Informatique-CDC, Research&development department */
/* company from the Caisse Des Depots et Consignations */
/* institutional financial group  */

/* theses symbols are added before this file */
/* #define YY_CHAR 'unsigned char' if 8bit or 'char' if 7bit */
/* #define FLEX_DEBUG if debug mode */
#define FLEX_SCANNER
/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
#ifdef c_plusplus
	#ifndef __cplusplus
		#define __cplusplus
	#endif
#endif
/* Old MSC, before c7 */
#ifdef MSDOS
	#ifndef _MSDOS
		#define _MSDOS
	#endif
#endif
/* turboc */
#ifdef __MSDOS__
	#ifndef _MSDOS
		#define _MSDOS
	#endif
#endif

#ifdef __cplusplus
	#include <stdlib.h>
	#define YY_USE_CONST
	#define YY_USE_PROTOS
	#ifndef YY_USE_CLASS
		#define YY_USE_CLASS
	#endif
	#if !defined(_MSDOS) && !defined(_WIN32)
		
	#endif
#else   /* ! __cplusplus */
	#ifdef __STDC__
		#ifdef __GNUC__
			#include <stddef.h>
			void* malloc( size_t );
			void free( void* );
			int read();
		#else
			#include <stdlib.h>
		#endif  /* __GNUC__ */
		#define YY_USE_PROTOS
		#define YY_USE_CONST
	#endif  /* __STDC__ */
#endif  /* ! __cplusplus */
#ifdef __TURBOC__
	#define YY_USE_CONST
#endif
#include <stdio.h>


/*********************************************/
/* COMPILER DEPENDENT   MACROS               */
/*********************************************/
/* use prototypes in function declarations */
/* the "const" storage-class-modifier is valid */
#ifndef YY_USE_CONST
	#define const
#endif
/* use prototypes in function declarations */
#ifndef YY_PROTO
	#ifdef YY_USE_PROTOS
		#define YY_PROTO(proto) proto
	#else
		#define YY_PROTO(proto) ()
	#endif
#endif


/*********************/
/* parameters        */

/* amount of stuff to slurp up with each read */
#ifndef YY_READ_BUF_SIZE
	#define YY_READ_BUF_SIZE 8192
#endif
/* size of default input buffer */
#ifndef YY_BUF_SIZE
	#define YY_BUF_SIZE (YY_READ_BUF_SIZE * 2)
#endif

/***********************************/
/* to be redefined for application */

/* returned upon end-of-file */
#define YY_END_TOK 0
/*  no semi-colon after return; correct usage is to write "yyterminate();" -
    we don't want an extra ';' after the "return" because that will cause
    some compilers to complain about unreachable statements.
*/
#define yyterminate() return ( YY_NULL )

/* code executed at the end of each rule */
#define YY_BREAK break;

/* #define YY_USER_ACTION */
/* #define YY_USER_INIT */


#ifndef YY_USE_CLASS
/* copy whatever the last rule matched to the standard output */
/* cast to (char *) is because for 8-bit chars, yy___text is (unsigned char *) */
/*  this used to be an fputs(), but since the string might contain NUL's,
    we now use fwrite()
*/
#define ECHO (void) fwrite( (char *) yy___text, yy___leng, 1, yy___out )

/*  gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
    is returned in "result".
*/
#ifdef _MSDOS
#define YY_INPUT(buf,result,max_size) \
	if ( (result = fread(buf,1,max_size,yy___in)) < 0 ) \
		YY_FATAL_ERROR( "fread() in flex scanner failed" );
#else
#define YY_INPUT(buf,result,max_size) \
	if ( (result = read( fileno(yy___in), (char *) buf, max_size )) < 0 ) \
		YY_FATAL_ERROR( "read() in flex scanner failed" );

#endif
/* report a fatal error */

/*  The funky do-while is used to turn this macro definition into
    a single C statement (which needs a semi-colon terminator).
    This avoids problems with code like:

        if ( something_happens )
                YY_FATAL_ERROR( "oops, the something happened" );
        else
                everything_okay();

    Prior to using the do-while the compiler would get upset at the
    "else" because it interpreted the "if" statement as being all
    done when it reached the ';' after the YY_FATAL_ERROR() call.
*/

#define YY_FATAL_ERROR(msg) \
	do \
	{ \
		(void) fputs( msg, yy___stderr  ); \
		(void) putc( '\n', yy___stderr  ); \
		exit( 1 ); \
	} \
	while ( 0 )

/* default yywrap function - always treat EOF as an EOF */
#define yywrap() 1


/*  default declaration of generated scanner - a define so the user can
    easily add parameters
*/
#define YY_DECL int yylex YY_PROTO(( void ))
#else
/* c++ */
#define ECHO yy___echo()
#define YY_INPUT(buf,result,max_size) \
	if ( yy___input((char *)buf, result,max_size) < 0 ) \
		YY_FATAL_ERROR( "YY_INPUT() in flex scanner failed" );

#define YY_FATAL_ERROR(msg) yy___fatal_error(msg)
#define yywrap() yy___wrap()

#endif
/***********************************/
/* not to be changed */
#define YY_NULL 0
#define YY_END_OF_BUFFER_CHAR 0
/* special action meaning "start processing a new file" */
#define YY_NEW_FILE yy___newfile
/*  enter a start condition.  This macro really ought to take a parameter,
    but we do it the disgusting crufty way forced on us by the ()-less
    definition of BEGIN
*/
#define BEGIN yy_start = 1 + 2 *

/* action number for EOF rule of a given start state */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)



/* % section 1 definitions go here */
#define INITIAL 0

#ifdef ECHO
	#undef ECHO							// Before PrimManip gets confused.
#endif

#include <Fog/FogIncludeAll.h>

#define INITIAL 0

#define ECHO { ERRMSG("BUG - Unexpected character " << c_string(yytext[0]) << " in " << state_name()); }
#define YY_FogLexer_FLEX_SCANNER
#define COMMENT_STATE 1
#define INCLUDE_STATE 2
#define SOAK_STATE 3
#define HASH_STATE 4
#define OFF_STATE 5
/* pp_ws is implementation defined as to whether to convert to a space. Here we convert */
/* An empty '' is valid FOG but not C++. Escapes are simplified to \. since any residue is easy */
#include "FogLexer.h"

#define yy___stderr YY_FogLexer_ERRFILE
#define yy___text YY_FogLexer_TEXT
#define yy___leng YY_FogLexer_LENG
#define yy___in YY_FogLexer_IN
#define yy___out YY_FogLexer_OUT
#define yy___newfile \
	do \
	{ \
		YY_FogLexer_INIT_BUFFER( YY_FogLexer_CURRENT_BUFFER, yy___in ); \
		YY_FogLexer_LOAD_BUFFER_STATE(); \
	} \
	while ( 0 )
#if YY_FogLexer_DEBUG != 0
	#define yy___flex_debug YY_FogLexer_DEBUG_FLAG
#endif


#ifdef YY_USE_CLASS
	
	#define yy___echo YY_FogLexer_ECHO
	#define yy___input YY_FogLexer_INPUT
	#define yy___fatal_error YY_FogLexer_FATAL_ERROR
	#define yy___wrap YY_FogLexer_WRAP
	
#endif

/*  done after the current pattern has been matched and before the
    corresponding action - sets up yy___text
*/
#define YY_DO_BEFORE_ACTION \
	yy___text = yy_bp; \
	/* % code to fiddle yy___text and yy___leng for yymore() goes here */ \
	yy___leng = yy_cp - yy_bp; \
	yy_hold_char = *yy_cp; \
	*yy_cp = '\0'; \
	yy_c_buf_p = yy_cp;

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2

/* return all but the first 'n' matched characters back to the input stream */
#define yyless(n) \
	do \
	{ \
		/* undo effects of setting up yy___text */ \
		*yy_cp = yy_hold_char; \
		yy_c_buf_p = yy_cp = yy_bp + n; \
		YY_DO_BEFORE_ACTION; /* set up yy___text again */ \
	} \
	while ( 0 )

#define unput(c) yyunput( c, yy___text )



struct yy_buffer_state {
	YY_FogLexer_IFILE*  yy_input_file;
	
	YY_FogLexer_CHAR* yy_ch_buf;               /* input buffer */
	YY_FogLexer_CHAR* yy_buf_pos;      /* current position in input buffer */
	
	/* size of input buffer in bytes, not including room for EOB characters */
	int yy_buf_size;
	
	/* number of characters read into yy_ch_buf, not including EOB characters */
	int yy_n_chars;
	
	int yy_eof_status;          /* whether we've seen an EOF on this buffer */
#define EOF_NOT_SEEN 0
	/*  "pending" happens when the EOF has been seen but there's still
	    some text process
	*/
#define EOF_PENDING 1
#define EOF_DONE 2
};

/*  we provide macros for accessing buffer states in case in the
    future we want to put the buffer states in a more general
    "scanner state"
*/

#ifndef YY_USE_CLASS

#if YY_FogLexer_DEBUG != 0
	int YY_FogLexer_DEBUG_FLAG = YY_FogLexer_DEBUG_INIT;
#endif
#define YY_CURRENT_BUFFER YY_FogLexer_CURRENT_BUFFER
static YY_BUFFER_STATE YY_FogLexer_CURRENT_BUFFER;
/* yy_hold_char holds the character lost when yy___text is formed */
static YY_FogLexer_CHAR yy_hold_char;

static int yy_n_chars;          /* number of characters read into yy_ch_buf */

/* GLOBAL */
YY_FogLexer_CHAR* yy___text;
int yy___leng;

YY_FogLexer_IFILE*  yy___in = (YY_FogLexer_IFILE*) 0;
YY_FogLexer_OFILE* yy___out = (YY_FogLexer_OFILE*) 0;

#ifdef __cplusplus
	static int yyinput YY_PROTO(( void ));
#else
	static int input YY_PROTO(( void ));
#endif
/*  these variables are all declared out here so that section 3 code can
    manipulate them
*/
/* points to current character in buffer */
static YY_FogLexer_CHAR* yy_c_buf_p = (YY_FogLexer_CHAR*) 0;
static int yy_init = 1;         /* whether we need to initialize */
static int yy_start = 0;        /* start state number */

/*  flag which is used to allow yywrap()'s to do buffer switches
    instead of setting up a fresh yy___in.  A bit of a hack ...
*/
static int yy_did_buffer_switch_on_eof;

static int yy_get_next_buffer YY_PROTO(( void ));
static void yyunput YY_PROTO(( YY_FogLexer_CHAR c, YY_FogLexer_CHAR* buf_ptr ));

#else
/* c++ */
#ifndef YY_FogLexer_ECHO_NOCODE
void YY_FogLexer_CLASS::yy___echo() {
	YY_FogLexer_ECHO_CODE
}
#endif
#ifndef YY_FogLexer_INPUT_NOCODE
int  YY_FogLexer_CLASS::yy___input(char* buffer, int& result, int max_size) {
	YY_FogLexer_INPUT_CODE
}
#endif
#ifndef YY_FogLexer_FATAL_ERROR_NOCODE
void YY_FogLexer_CLASS::yy___fatal_error(const char* msg) {
	YY_FogLexer_FATAL_ERROR_CODE
}
#endif
#ifndef YY_FogLexer_WRAP_NOCODE
int  YY_FogLexer_CLASS::yy___wrap() {
	YY_FogLexer_WRAP_CODE
}
#endif
void YY_FogLexer_CLASS::yy_initialize() {
	yy___in = 0; yy___out = 0; yy_init = 1;
	yy_start = 0;
	yy___text = 0; yy___leng = 0;
	YY_FogLexer_CURRENT_BUFFER = 0;
	yy_did_buffer_switch_on_eof = 0;
	yy_c_buf_p = 0; yy_hold_char = 0; yy_n_chars = 0;
#if YY_FogLexer_DEBUG != 0
	YY_FogLexer_DEBUG_FLAG = YY_FogLexer_DEBUG_INIT;
#endif
}

YY_FogLexer_CLASS::YY_FogLexer_CLASS(YY_FogLexer_CONSTRUCTOR_PARAM) YY_FogLexer_CONSTRUCTOR_INIT {
	yy_initialize();
	YY_FogLexer_CONSTRUCTOR_CODE;
}
YY_FogLexer_CLASS::~YY_FogLexer_CLASS() {
	YY_FogLexer_DESTRUCTOR_CODE;
	
	if (YY_FogLexer_CURRENT_BUFFER)
		YY_FogLexer_DELETE_BUFFER(YY_FogLexer_CURRENT_BUFFER);
}

#endif


#ifndef YY_USER_ACTION
	#define YY_USER_ACTION
#endif

#ifndef YY_USER_INIT
	#define YY_USER_INIT
#endif

/* % data tables for the DFA go here */
#define YY_END_OF_BUFFER 91
typedef int yy_state_type;
static const short int yy_accept[569] = {
	0,
	0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,   91,   82,   81,   83,   82,   39,   42,   82,
	82,   36,   82,   82,   82,   82,   82,   82,   82,   40,
	82,   82,   82,   82,   41,   41,   48,   82,   52,   82,
	46,   82,   50,   82,   81,   16,   82,    2,    2,    5,
	2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
	2,    2,    3,    2,    2,    2,    2,    2,    2,    2,
	2,    2,    2,    2,    2,    2,    2,    2,   39,   82,
	12,   12,   12,   12,   12,   12,   12,   12,   12,   12,
	12,   12,   12,   12,   12,   12,   12,   12,   12,   12,
	
	12,   12,   12,   12,   12,   12,   12,   12,   12,   12,
	12,   32,   32,   33,   32,   32,   32,   32,   32,   32,
	32,   18,   17,    4,   18,   18,   18,   18,   18,   18,
	18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
	18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
	18,   18,   17,   15,   18,   81,    0,   59,   39,   37,
	38,   44,   43,   73,   51,   62,   75,   36,   34,   35,
	71,   64,   69,   65,   70,   67,   68,    0,   40,   11,
	8,   72,   40,   40,    0,   54,   53,   47,   49,   56,
	60,   58,   61,   57,   41,    0,   39,   36,   85,   79,
	
	79,   85,   85,   85,   74,   76,   63,   81,   16,    0,
	16,    2,    2,    2,    2,    2,    2,    2,    2,    2,
	2,    2,    2,    2,    2,    1,    2,    2,    2,    2,
	2,   84,    2,    2,    2,    2,    2,    2,    2,    2,
	2,    2,    2,    2,    2,    2,    2,    2,    2,   39,
	13,   38,    0,   47,   49,   56,   60,   14,   12,   39,
	12,   38,   12,   12,   12,   12,   12,   12,   36,   12,
	35,   12,   12,   12,   12,   12,   12,   12,    0,   12,
	12,   12,   12,    0,   12,   12,   12,   12,   12,   12,
	12,   12,   12,   12,    0,   39,   36,   12,   12,   12,
	
	12,   12,   12,   12,   12,   12,   12,    0,    0,    9,
	6,    0,    0,    0,    0,   25,    0,    0,    0,    0,
	17,    0,   18,    0,   18,    0,   18,   18,   18,   18,
	0,    0,   18,   18,    0,   18,   10,    7,   18,   18,
	0,   18,   18,   18,   18,   18,   18,    0,    0,    0,
	18,   18,   18,   17,   15,    0,   15,    0,   66,   55,
	8,    0,    0,   78,   77,    0,    0,   79,    0,    0,
	79,    1,    2,    1,    2,    0,    2,    2,    2,    2,
	2,    2,   13,   78,    0,   12,   12,    0,    0,   12,
	12,    0,    0,    0,    0,    6,    0,    0,    0,    0,
	
	0,    0,    0,    0,    0,    0,    0,    0,    7,    0,
	0,    0,    0,    0,    0,   45,    0,    0,    0,    0,
	79,    0,    0,    0,   84,    2,    0,    0,    2,    0,
	2,    2,    2,    2,    2,    2,   12,    0,    0,    0,
	0,    0,    0,    0,   21,   22,    0,    0,    0,    0,
	0,   29,    0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,    2,    2,
	2,    2,    2,    2,    0,    0,    0,    0,    0,    0,
	0,   23,   24,   26,    0,    0,    0,   31,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,    0,   41,
	
	2,    2,    2,    2,    2,    2,    0,    0,    0,    0,
	0,   12,   20,   27,    0,   30,    0,    0,    0,    0,
	0,   18,    0,    0,    0,    2,    2,    2,    0,    0,
	0,   28,    0,    0,    0,    0,    0,    0,    2,    2,
	2,    0,    0,    0,    0,    0,    0,    0,    0,    0,
	2,    2,    2,    0,    0,    0,    0,    0,    0,    0,
	0,    2,    2,    0,    0,    0,    0,    0
} ;

static const YY_CHAR yy_ec[128] = {
	0,
	1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
	2,    2,    1,    1,    1,    1,    1,    1,    1,    1,
	1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
	1,    2,    4,    5,    6,    1,    7,    8,    9,   10,
	11,   12,   13,   14,   15,   16,   17,   18,   18,   18,
	18,   18,   18,   18,   18,   19,   19,   20,   21,   22,
	23,   24,   25,    1,   26,   26,   26,   26,   27,   26,
	28,   28,   28,   28,   28,   29,   28,   28,   28,   28,
	28,   28,   28,   28,   30,   28,   28,   28,   28,   28,
	31,   32,   33,   34,   28,    1,   35,   36,   37,   38,
	
	39,   40,   41,   28,   42,   28,   28,   43,   44,   45,
	46,   47,   28,   48,   49,   50,   51,   52,   28,   53,
	28,   28,   54,   55,   56,   57,    1
} ;

static const YY_CHAR yy_meta[58] = {
	0,
	1,    1,    2,    1,    1,    1,    1,    1,    1,    1,
	1,    1,    1,    1,    1,    3,    1,    4,    4,    1,
	1,    1,    1,    1,    1,    4,    4,    5,    5,    5,
	1,    5,    1,    1,    4,    4,    4,    4,    4,    4,
	5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
	5,    5,    5,    1,    1,    1,    1
} ;

static const short int yy_base[710] = {
	0,
	0,   56,   63,    0,  116,  120,  142,  122,  198,  248,
	299,  128, 1139, 1945,  200, 1945, 1115,  198, 1131,  113,
	196,  196, 1945, 1111,  118, 1945,  197,  195,  206,  195,
	186,  224, 1110,   36, 1100,  230, 1945,  352, 1945, 1108,
	1945,  193, 1945, 1945,  236, 1124,  232, 1110, 1109, 1945,
	245,  249,  220,  246,  251,  264, 1108,  255,  270, 1107,
	265,  346,  262,  405,  347,  356,  248,  357,  451,  289,
	1106,  454, 1105,  252, 1104,  452, 1101, 1100,  361,  499,
	1945, 1088,  367, 1104,  366,  201,  351, 1945, 1086,  362,
	1945,  450,  496,  459,  369,  371,  504, 1085,  116, 1073,
	
	504, 1945,  532, 1945, 1081, 1945,  462, 1945, 1945, 1097,
	505, 1945,  514, 1945,  280, 1063,  487,  427, 1059, 1045,
	1047, 1945,  516, 1945, 1068,  515, 1084,  519,  526,  529,
	1945, 1066,  531, 1945,  536,  557,  569,  513,  374,  567,
	1065,  350, 1055,  561, 1945,  528, 1945, 1061, 1945,  523,
	1945, 1945,  589, 1077,  574,  546,  587, 1945,  583, 1945,
	0, 1945, 1075, 1945, 1945, 1945, 1945,  591, 1945,    0,
	1945, 1945, 1945, 1945, 1945, 1069, 1945, 1064,  575, 1945,
	0, 1945,  578,  598,  571, 1945, 1945, 1945, 1945, 1056,
	1945, 1945, 1945, 1053, 1043,  573,  603,  600, 1945, 1945,
	
	1056,    0,    0,    0, 1945, 1945, 1945,  614, 1945, 1053,
	1065, 1052,  616, 1051,  607, 1050,  624, 1049, 1048,  631,
	1047, 1046,  633,  635, 1043, 1037, 1041,  634,  637,    0,
	638, 1945,    0,  540,  628, 1040, 1039, 1038, 1035,  636,
	645,    0,  642,  657,  651, 1034,  649,  682,  711,  659,
	1945, 1040, 1020, 1019, 1011,  603, 1010, 1945, 1945,  665,
	1945,    0, 1945, 1026, 1945, 1945, 1945, 1945,  664, 1945,
	0, 1945, 1945, 1945, 1945, 1945, 1020, 1945, 1015,  648,
	1945,  649,  671,  641, 1945, 1945, 1945, 1945, 1007, 1945,
	1945, 1945, 1006,  994,  644,  672,  673, 1945, 1945, 1007,
	
	0,    0,    0, 1945, 1945, 1945, 1017,  554,  673, 1945,
	0,  983,  657,  984,  973,  669,  981,  972,  981,  977,
	709,  715, 1945,  707, 1945,    0, 1945, 1007, 1945, 1945,
	693,    0,  994, 1945,  989,  701, 1945,    0,  704,  729,
	683, 1945, 1945, 1945,  981,  980,  970,  694,  730,  732,
	1945,    0,    0,  752, 1945,  981,  993,  977, 1945, 1945,
	0,    0,    0, 1945, 1945,    0,    0,  978,    0,    0,
	0,  748,  213,  743,  754,  978,  769,  798,  827,  856,
	885,  914,  750,  970,  973, 1945, 1945,    0,    0, 1945,
	1945,    0,    0,    0,    0,    0,  950,  949,  949,  945,
	
	940,  946,  939,  933,  936,  933,  934,  952,    0,    0,
	0,    0,    0,    0,    0, 1945,    0,    0,    0,    0,
	1945,    0,    0,  752, 1945,  762,    0,  754,  761,    0,
	943,  972, 1001, 1030, 1059, 1088, 1945,    0,    0,    0,
	0,    0,    0,  926, 1945, 1945,  928,  919,  926,  926,
	913, 1945,  919,  920,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,  780,  781, 1117, 1146,
	1175, 1204, 1233, 1262,    0,    0,    0,    0,    0,    0,
	920, 1945, 1945, 1945,  918,  919,  921, 1945,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,    0,  916,
	
	1291, 1320, 1349, 1378, 1407, 1436,    0,    0,    0,    0,
	0,  915, 1945, 1945,  907, 1945,    0,    0,    0,    0,
	0,  913,    0,    0,    0, 1478, 1507, 1536,    0,    0,
	0, 1945,    0,    0,    0,    0,    0,    0, 1565, 1594,
	1623,    0,    0,    0,    0,    0,    0,    0,    0,    0,
	1652, 1681, 1710,    0,    0,    0,    0,    0,    0,    0,
	0, 1739, 1768,    0,    0,    0,    0, 1945, 1808, 1813,
	1818, 1821, 1823, 1828, 1833, 1838, 1843, 1848, 1853, 1858,
	1863, 1868, 1871, 1873, 1878, 1883, 1888, 1891, 1893, 1898,
	1903,  940,  939,  938,  935,  934, 1908, 1913,  933,  932,
	
	931,  930,  927,  926,  925,  924, 1918, 1923,  923,  915,
	914,  913,  912,  911,  910,  909,  906,  905,  904,  903,
	902,  901,  898,  897,  896,  895, 1928, 1933,  894,  886,
	885,  884,  883,  882,  881,  880,  877,  876,  875,  874,
	873,  872,  869,  868,  867,  866,  865,  857,  856,  855,
	854,  853,  852,  851,  848,  847,  846,  845,  844,  843,
	840,  839,  838, 1935,  837,  836,  828,  827,  826, 1937,
	825,  824,  823,  822,  819, 1939,  818,  817,  816,  815,
	814,  811,  810,  807,  799,  798,  797,  796,  795,  788,
	787,  785,  779,  773,  772,  768,  712,  711,  674,  630,
	
	614,  561,  506,  464,  280,  204,  128,  119,   57
} ;

static const short int yy_def[710] = {
	0,
	568,    1,  568,    3,    1,    1,  568,    7,  569,  569,
	568,   11,  568,  568,  568,  568,  568,  570,  568,  568,
	568,  571,  568,  568,  568,  568,  568,  568,  568,  572,
	568,  568,  568,  568,  573,  573,  568,  574,  568,  568,
	568,  568,  568,  568,  568,  568,  568,  575,  575,  568,
	575,  576,  575,  575,  575,  577,  575,  575,  575,  575,
	575,  575,  568,  568,  575,  575,  575,  575,  575,   69,
	575,  578,  575,  575,  575,  575,  575,  575,  579,  580,
	568,  568,  581,  568,  568,  568,  582,  568,  568,  568,
	568,  568,  568,  568,  583,  568,  568,  568,  568,  584,
	
	584,  568,  585,  568,  568,  568,  568,  568,  568,  568,
	568,  568,  568,  568,  568,  568,  568,  568,  568,  568,
	568,  568,  568,  568,  568,  586,  568,  568,  568,  587,
	568,  568,  568,  568,  568,  568,  568,  588,  568,  568,
	568,  568,  589,  589,  568,  590,  568,  568,  568,  568,
	568,  568,  568,  568,  568,  568,  568,  568,  570,  568,
	570,  568,  568,  568,  568,  568,  568,  571,  568,  571,
	568,  568,  568,  568,  568,  568,  568,  568,  572,  568,
	591,  568,  572,  572,  568,  568,  568,  568,  568,  568,
	568,  568,  568,  568,  573,  568,  570,  571,  568,  568,
	
	568,  592,  593,  594,  568,  568,  568,  568,  568,  568,
	568,  575,  575,  575,  576,  575,  576,  576,  575,  575,
	575,  575,  577,  577,  577,  568,  575,  575,  575,   64,
	575,  568,   64,   64,  575,  575,  575,  575,  575,  575,
	575,   69,  575,  576,  577,  575,  575,  575,  575,  579,
	568,  579,  580,  580,  580,  580,  580,  568,  568,  581,
	568,  581,  568,  568,  568,  568,  568,  568,  582,  568,
	582,  568,  568,  568,  568,  568,  568,  568,  568,  583,
	568,  583,  583,  568,  568,  568,  568,  568,  568,  568,
	568,  568,  568,  584,  568,  581,  582,  568,  568,  568,
	
	595,  596,  594,  568,  568,  568,  568,  568,  568,  568,
	597,  568,  568,  568,  568,  568,  568,  568,  568,  568,
	568,  568,  568,  586,  568,  586,  568,  568,  568,  568,
	587,  587,  568,  568,  568,  588,  568,  598,  588,  588,
	568,  568,  568,  568,  568,  568,  589,  568,  586,  587,
	568,  599,  600,  568,  568,  568,  568,  568,  568,  568,
	591,  601,  602,  568,  568,  603,  604,  568,  605,  606,
	594,  607,  575,  608,  575,  568,  575,  575,  575,  575,
	575,  575,  570,  580,  568,  568,  568,  609,  610,  568,
	568,  611,  612,  613,  614,  597,  568,  568,  568,  568,
	
	568,  568,  568,  568,  568,  568,  568,  568,  598,  615,
	616,  617,  618,  619,  620,  568,  621,  622,  623,  624,
	568,  625,  626,  607,  568,  627,  607,  608,  628,  608,
	575,  575,  575,  575,  575,  575,  568,  629,  630,  631,
	632,  633,  634,  568,  568,  568,  568,  568,  568,  568,
	568,  568,  568,  568,  635,  636,  637,  638,  639,  640,
	641,  642,  643,  644,  645,  646,  607,  608,  575,  575,
	575,  575,  575,  575,  647,  648,  649,  650,  651,  652,
	568,  568,  568,  568,  568,  568,  568,  568,  653,  654,
	655,  656,  657,  658,  659,  660,  661,  662,  663,  664,
	
	575,  575,  575,  575,  575,  575,  665,  666,  667,  668,
	669,  670,  568,  568,  568,  568,  671,  672,  673,  674,
	675,  676,  677,  678,  679,  575,  575,  575,  680,  681,
	682,  568,  683,  684,  685,  686,  687,  688,  575,  575,
	575,  689,  690,  691,  692,  693,  694,  695,  696,  697,
	575,  575,  575,  698,  699,  700,  701,  702,  703,  704,
	705,  575,  575,  706,  707,  708,  709,    0,  568,  568,
	568,  568,  568,  568,  568,  568,  568,  568,  568,  568,
	568,  568,  568,  568,  568,  568,  568,  568,  568,  568,
	568,  568,  568,  568,  568,  568,  568,  568,  568,  568,
	
	568,  568,  568,  568,  568,  568,  568,  568,  568,  568,
	568,  568,  568,  568,  568,  568,  568,  568,  568,  568,
	568,  568,  568,  568,  568,  568,  568,  568,  568,  568,
	568,  568,  568,  568,  568,  568,  568,  568,  568,  568,
	568,  568,  568,  568,  568,  568,  568,  568,  568,  568,
	568,  568,  568,  568,  568,  568,  568,  568,  568,  568,
	568,  568,  568,  568,  568,  568,  568,  568,  568,  568,
	568,  568,  568,  568,  568,  568,  568,  568,  568,  568,
	568,  568,  568,  568,  568,  568,  568,  568,  568,  568,
	568,  568,  568,  568,  568,  568,  568,  568,  568,  568,
	
	568,  568,  568,  568,  568,  568,  568,  568,  568
} ;

static const short int yy_nxt[2003] = {
	0,
	14,   15,   16,   17,   18,   19,   20,   21,   22,   23,
	23,   24,   25,   26,   27,   28,   29,   30,   30,   31,
	23,   32,   33,   34,   23,   35,   35,   35,   36,   35,
	37,   38,   39,   40,   35,   35,   35,   35,   35,   35,
	35,   35,   35,   35,   35,   35,   35,   35,   35,   35,
	35,   35,   35,   41,   42,   43,   44,   45,  193,  194,
	347,   46,   47,   48,   49,   50,   51,   52,   53,   54,
	55,   56,   57,   57,   58,   59,   60,   61,   62,   63,
	64,   64,   65,   57,   66,   67,   68,   57,   69,   69,
	69,   70,   69,   71,   72,   73,   74,   69,   69,   69,
	
	69,   69,   69,   69,   69,   69,   69,   69,   69,   69,
	69,   69,   69,   69,   69,   69,   75,   76,   77,   78,
	79,   45,  339,   45,   79,   46,   47,  110,  111,  153,
	172,  294,  163,  154,  155,  164,  165,   80,  292,  293,
	173,   80,   81,   15,   16,   82,   83,   84,   85,   86,
	87,   88,   88,   89,   90,   91,   92,   93,   94,   95,
	95,   96,   88,   97,   98,   99,   88,  100,  100,  100,
	101,  100,  102,  103,  104,  105,  100,  100,  100,  100,
	100,  100,  100,  100,  100,  100,  100,  100,  100,  100,
	100,  100,  100,  100,  100,  106,  107,  108,  109,  113,
	
	114,  156,  160,  166,  169,  186,  177,  282,  267,  187,
	178,  174,  179,  179,  115,  206,  157,  180,  167,  175,
	176,  184,  181,  268,  213,  219,  185,  170,  182,  161,
	188,  213,  219,  184,  197,  116,  117,  208,  198,  118,
	119,  209,  210,  189,  120,  190,  191,  207,  121,  113,
	114,  211,  157,  216,  164,  165,  213,  213,  214,  213,
	217,  196,  213,  213,  115,  220,  213,  214,  221,  222,
	214,  226,  216,  221,  221,  224,  213,  221,  231,  214,
	218,  213,  214,  195,  232,  116,  117,  221,  227,  118,
	119,  310,  221,  244,  120,  225,  311,  245,  121,  122,
	
	123,  124,  125,  126,  127,  128,  129,  130,  131,  131,
	132,  133,  134,  135,  136,  137,  138,  138,  139,  131,
	140,  141,  142,  131,  143,  143,  143,  144,  143,  145,
	146,  147,  148,  143,  143,  143,  143,  143,  143,  143,
	143,  143,  143,  143,  143,  143,  143,  143,  143,  143,
	143,  143,  149,  150,  151,  152,  200,  228,  213,  270,
	200,  229,  238,  230,  230,  251,  236,  213,  213,  201,
	237,  261,  323,  346,  273,  239,  200,  240,  214,  214,
	241,  202,  271,  200,  274,  264,  200,  200,  265,  266,
	285,  200,  252,  334,  286,  283,  200,  342,  262,  200,
	
	284,  200,  203,  200,  204,  212,  212,  283,  212,  212,
	212,  212,  212,  212,  212,  212,  213,  212,  212,  212,
	233,  212,  233,  233,  212,  212,  212,  212,  212,  212,
	233,  234,  233,  233,  233,  212,  235,  212,  212,  233,
	233,  233,  233,  234,  233,  233,  233,  233,  233,  233,
	233,  233,  233,  233,  233,  233,  233,  233,  212,  212,
	212,  212,  213,  213,  275,  247,  316,  183,  242,  242,
	180,  317,  276,  277,  221,  181,  242,  242,  242,  242,
	242,  281,  243,  248,  305,  242,  242,  242,  242,  242,
	242,  242,  242,  242,  242,  242,  242,  242,  242,  242,
	
	242,  242,  242,  242,  249,  254,  214,  278,  296,  522,
	287,  279,  297,  280,  280,  308,  306,  321,  255,  325,
	256,  257,  258,  288,  307,  289,  290,  265,  266,  313,
	309,  314,  322,  323,  315,  295,  299,  325,  328,  340,
	299,  329,  330,  323,  341,  329,  326,  156,  329,  300,
	323,  340,  233,  329,  233,  308,  299,  352,  329,  333,
	332,  301,  157,  299,  567,  349,  299,  299,  334,  350,
	309,  299,  335,  343,  336,  336,  299,  323,  353,  299,
	337,  299,  302,  299,  303,  338,  344,  160,  345,  323,
	354,  329,  348,  357,  355,  356,  329,  330,  180,  169,
	
	362,  184,  366,  181,  184,  322,  185,  160,  169,  185,
	183,  216,  183,  184,  161,  208,  184,  566,  217,  209,
	210,  363,  170,  367,  184,  384,  258,  213,  216,  185,
	157,  170,  226,  512,  161,  217,  184,  373,  218,  213,
	372,  216,  213,  216,  224,  213,  224,  213,  213,  213,
	226,  374,  236,  213,  376,  218,  213,  377,  221,  216,
	213,  216,  224,  251,  225,  226,  225,  221,  217,  261,
	388,  379,  270,  392,  283,  283,  261,  565,  378,  284,
	284,  270,  225,  282,  310,  282,  283,  283,  218,  311,
	252,  389,  380,  213,  393,  271,  262,  283,  398,  381,
	
	381,  325,  284,  262,  271,  399,  402,  381,  381,  283,
	321,  325,  410,  403,  564,  500,  381,  381,  381,  381,
	381,  381,  213,  412,  332,  322,  337,  340,  382,  382,
	340,  338,  341,  411,  325,  341,  382,  382,  326,  340,
	325,  339,  340,  339,  413,  382,  382,  382,  382,  382,
	382,  425,  425,  354,  160,  340,  425,  355,  356,  429,
	341,  326,  425,  332,  426,  213,  216,  340,  322,  216,
	226,  561,  224,  217,  430,  560,  559,  468,  467,  427,
	213,  161,  558,  427,  425,  430,  431,  431,  557,  425,
	556,  555,  225,  218,  431,  431,  426,  429,  554,  550,
	
	549,  548,  547,  431,  431,  431,  431,  431,  431,  213,
	546,  427,  430,  545,  544,  432,  432,  543,  542,  538,
	537,  536,  535,  432,  432,  347,  534,  339,  533,  531,
	294,  530,  432,  432,  432,  432,  432,  432,  213,  282,
	529,  525,  195,  524,  433,  433,  183,  523,  522,  521,
	520,  519,  433,  433,  518,  517,  512,  511,  510,  509,
	508,  433,  433,  433,  433,  433,  433,  213,  507,  500,
	499,  498,  497,  434,  434,  496,  495,  494,  493,  492,
	491,  434,  434,  490,  489,  480,  479,  478,  477,  476,
	434,  434,  434,  434,  434,  434,  213,  475,  466,  465,
	
	464,  463,  435,  435,  462,  461,  460,  459,  458,  457,
	435,  435,  456,  455,  443,  442,  441,  440,  439,  435,
	435,  435,  435,  435,  435,  213,  438,  423,  422,  420,
	419,  436,  436,  418,  417,  415,  414,  395,  394,  436,
	436,  371,  370,  369,  348,  532,  295,  196,  436,  436,
	436,  436,  436,  436,  213,  516,  515,  514,  513,  488,
	469,  469,  487,  486,  485,  484,  483,  482,  469,  469,
	481,  327,  454,  453,  452,  451,  450,  469,  469,  469,
	469,  469,  469,  213,  449,  448,  447,  446,  445,  470,
	470,  444,  437,  258,  231,  421,  416,  470,  470,  408,
	
	355,  348,  329,  329,  334,  323,  470,  470,  470,  470,
	470,  470,  213,  408,  407,  406,  405,  404,  471,  471,
	401,  400,  397,  385,  368,  295,  471,  471,  391,  390,
	387,  386,  385,  258,  258,  471,  471,  471,  471,  471,
	471,  213,  258,  258,  383,  213,  213,  472,  472,  213,
	213,  213,  375,  231,  224,  472,  472,  213,  213,  213,
	217,  213,  213,  213,  472,  472,  472,  472,  472,  472,
	213,  358,  209,  368,  196,  365,  473,  473,  364,  360,
	359,  358,  327,  329,  473,  473,  348,  323,  329,  327,
	323,  320,  319,  473,  473,  473,  473,  473,  473,  213,
	
	318,  312,  263,  304,  295,  474,  474,  291,  272,  263,
	259,  213,  213,  474,  474,  213,  213,  213,  213,  213,
	213,  213,  474,  474,  474,  474,  474,  474,  213,  162,
	205,  196,  192,  171,  501,  501,  162,  158,  568,  568,
	568,  568,  501,  501,  568,  568,  568,  568,  568,  568,
	568,  501,  501,  501,  501,  501,  501,  213,  568,  568,
	568,  568,  568,  502,  502,  568,  568,  568,  568,  568,
	568,  502,  502,  568,  568,  568,  568,  568,  568,  568,
	502,  502,  502,  502,  502,  502,  213,  568,  568,  568,
	568,  568,  503,  503,  568,  568,  568,  568,  568,  568,
	
	503,  503,  568,  568,  568,  568,  568,  568,  568,  503,
	503,  503,  503,  503,  503,  213,  568,  568,  568,  568,
	568,  504,  504,  568,  568,  568,  568,  568,  568,  504,
	504,  568,  568,  568,  568,  568,  568,  568,  504,  504,
	504,  504,  504,  504,  213,  568,  568,  568,  568,  568,
	505,  505,  568,  568,  568,  568,  568,  568,  505,  505,
	568,  568,  568,  568,  568,  568,  568,  505,  505,  505,
	505,  505,  505,  213,  568,  568,  568,  568,  568,  506,
	506,  568,  568,  568,  568,  568,  568,  506,  506,  568,
	568,  568,  568,  568,  568,  568,  506,  506,  506,  506,
	
	506,  506,  213,  568,  568,  568,  568,  568,  526,  526,
	568,  568,  568,  568,  568,  568,  526,  526,  568,  568,
	568,  568,  568,  568,  568,  526,  526,  526,  526,  526,
	526,  213,  568,  568,  568,  568,  568,  233,  233,  568,
	568,  568,  568,  568,  568,  233,  233,  568,  568,  568,
	568,  568,  568,  568,  233,  233,  233,  233,  233,  233,
	213,  568,  568,  568,  568,  568,  527,  527,  568,  568,
	568,  568,  568,  568,  527,  527,  568,  568,  568,  568,
	568,  568,  568,  527,  527,  527,  527,  527,  527,  213,
	568,  568,  568,  568,  568,  242,  242,  568,  568,  568,
	
	568,  568,  568,  242,  242,  568,  568,  568,  568,  568,
	568,  568,  242,  242,  242,  242,  242,  242,  213,  568,
	568,  568,  568,  568,  528,  528,  568,  568,  568,  568,
	568,  568,  528,  528,  568,  568,  568,  568,  568,  568,
	568,  528,  528,  528,  528,  528,  528,  213,  568,  568,
	568,  568,  568,  242,  242,  568,  568,  568,  568,  568,
	568,  242,  242,  242,  242,  242,  568,  243,  568,  568,
	242,  242,  242,  242,  242,  242,  242,  242,  242,  242,
	242,  242,  242,  242,  242,  242,  242,  242,  242,  213,
	568,  568,  568,  568,  568,  539,  539,  568,  568,  568,
	
	568,  568,  568,  539,  539,  568,  568,  568,  568,  568,
	568,  568,  539,  539,  539,  539,  539,  539,  213,  568,
	568,  568,  568,  568,  540,  540,  568,  568,  568,  568,
	568,  568,  540,  540,  568,  568,  568,  568,  568,  568,
	568,  540,  540,  540,  540,  540,  540,  213,  568,  568,
	568,  568,  568,  541,  541,  568,  568,  568,  568,  568,
	568,  541,  541,  568,  568,  568,  568,  568,  568,  568,
	541,  541,  541,  541,  541,  541,  213,  568,  568,  568,
	568,  568,  551,  551,  568,  568,  568,  568,  568,  568,
	551,  551,  568,  568,  568,  568,  568,  568,  568,  551,
	
	551,  551,  551,  551,  551,  213,  568,  568,  568,  568,
	568,  552,  552,  568,  568,  568,  568,  568,  568,  552,
	552,  568,  568,  568,  568,  568,  568,  568,  552,  552,
	552,  552,  552,  552,  213,  568,  568,  568,  568,  568,
	553,  553,  568,  568,  568,  568,  568,  568,  553,  553,
	568,  568,  568,  568,  568,  568,  568,  553,  553,  553,
	553,  553,  553,  213,  568,  568,  568,  568,  568,  562,
	562,  568,  568,  568,  568,  568,  568,  562,  562,  568,
	568,  568,  568,  568,  568,  568,  562,  562,  562,  562,
	562,  562,  213,  568,  568,  568,  568,  568,  563,  563,
	
	568,  568,  568,  568,  568,  568,  563,  563,  568,  568,
	568,  568,  568,  568,  568,  563,  563,  563,  563,  563,
	563,  213,  568,  568,  568,  568,  568,  506,  506,  568,
	568,  568,  568,  568,  568,  506,  506,  568,  568,  568,
	568,  568,  568,  568,  506,  506,  506,  506,  506,  506,
	213,  568,  568,  568,  568,  568,  233,  233,  568,  568,
	568,  568,  568,  568,  233,  233,  568,  568,  568,  568,
	568,  568,  568,  233,  233,  233,  233,  233,  233,  213,
	568,  568,  568,  568,  568,  242,  242,  568,  568,  568,
	568,  568,  568,  242,  242,  568,  568,  568,  568,  568,
	
	568,  568,  242,  242,  242,  242,  242,  242,  112,  112,
	112,  112,  112,  159,  568,  159,  159,  159,  168,  568,
	168,  168,  168,  183,  183,  183,  195,  195,  199,  568,
	199,  199,  199,  212,  568,  212,  212,  212,  215,  568,
	215,  215,  215,  223,  568,  223,  223,  223,  246,  568,
	246,  246,  246,  250,  568,  250,  250,  250,  253,  568,
	253,  253,  253,  260,  568,  260,  260,  260,  269,  568,
	269,  269,  269,  282,  282,  282,  294,  294,  298,  568,
	298,  298,  298,  324,  568,  324,  324,  324,  331,  568,
	331,  331,  331,  339,  339,  339,  347,  347,  351,  568,
	
	351,  351,  351,  361,  568,  361,  361,  361,  396,  568,
	396,  396,  396,  409,  568,  409,  409,  409,  424,  568,
	424,  424,  424,  428,  568,  428,  428,  428,  215,  568,
	215,  215,  215,  223,  568,  223,  223,  223,  195,  195,
	294,  294,  347,  347,   13,  568,  568,  568,  568,  568,
	568,  568,  568,  568,  568,  568,  568,  568,  568,  568,
	568,  568,  568,  568,  568,  568,  568,  568,  568,  568,
	568,  568,  568,  568,  568,  568,  568,  568,  568,  568,
	568,  568,  568,  568,  568,  568,  568,  568,  568,  568,
	568,  568,  568,  568,  568,  568,  568,  568,  568,  568,
	
	568,  568
} ;

static const short int yy_chk[2003] = {
	0,
	1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
	1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
	1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
	1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
	1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
	1,    1,    1,    1,    1,    1,    1,    2,   34,   34,
	709,    2,    2,    3,    3,    3,    3,    3,    3,    3,
	3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
	3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
	3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
	
	3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
	3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
	5,    6,  708,    8,    6,    6,    6,    8,    8,   12,
	25,  707,   20,   12,   12,   20,   20,    5,   99,   99,
	25,    6,    7,    7,    7,    7,    7,    7,    7,    7,
	7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
	7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
	7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
	7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
	7,    7,    7,    7,    7,    7,    7,    7,    7,    9,
	
	9,   15,   18,   21,   22,   31,   28,  706,   86,   31,
	28,   27,   28,   28,    9,   42,   15,   29,   21,   27,
	27,   30,   29,   86,  373,   53,   30,   22,   29,   18,
	32,   53,  373,   30,   36,    9,    9,   45,   36,    9,
	9,   45,   45,   32,    9,   32,   32,   42,    9,   10,
	10,   47,   45,   52,   47,   47,   51,   54,   55,   67,
	52,   36,   55,   74,   10,   54,   58,   51,   54,   54,
	67,   58,   56,   55,   74,   56,   61,   58,   63,   61,
	52,   59,   59,  705,   63,   10,   10,   61,   61,   10,
	10,  115,   59,   70,   10,   56,  115,   70,   10,   11,
	
	11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
	11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
	11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
	11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
	11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
	11,   11,   11,   11,   11,   11,   38,   62,   65,   87,
	38,   62,   66,   62,   62,   79,   65,   66,   68,   38,
	65,   83,  142,  142,   90,   66,   38,   66,   66,   68,
	68,   38,   87,   38,   90,   85,   38,   38,   85,   85,
	96,   38,   79,  139,   96,   95,   38,  139,   83,   38,
	
	95,   38,   38,   38,   38,   64,   64,   95,   64,   64,
	64,   64,   64,   64,   64,   64,   64,   64,   64,   64,
	64,   64,   64,   64,   64,   64,   64,   64,   64,   64,
	64,   64,   64,   64,   64,   64,   64,   64,   64,   64,
	64,   64,   64,   64,   64,   64,   64,   64,   64,   64,
	64,   64,   64,   64,   64,   64,   64,   64,   64,   64,
	64,   64,   69,   76,   92,   72,  118,  704,   69,   69,
	94,  118,   92,   92,   76,   94,   69,   69,   69,   69,
	69,   94,   69,   72,  107,   69,   69,   69,   69,   69,
	69,   69,   69,   69,   69,   69,   69,   69,   69,   69,
	
	69,   69,   69,   69,   72,   80,   76,   93,  101,  703,
	97,   93,  101,   93,   93,  113,  107,  123,   80,  126,
	80,   80,   80,   97,  111,   97,   97,  111,  111,  117,
	113,  117,  123,  129,  117,  101,  103,  130,  128,  138,
	103,  128,  128,  133,  138,  150,  126,  156,  129,  103,
	135,  138,  234,  133,  234,  308,  103,  146,  135,  135,
	130,  103,  156,  103,  702,  144,  103,  103,  136,  144,
	308,  103,  136,  140,  136,  136,  103,  150,  146,  103,
	137,  103,  103,  103,  103,  137,  140,  159,  140,  140,
	153,  137,  144,  155,  153,  153,  155,  155,  157,  168,
	
	185,  179,  196,  157,  183,  153,  179,  197,  198,  183,
	184,  215,  184,  179,  159,  208,  183,  701,  215,  208,
	208,  185,  168,  196,  184,  256,  256,  213,  217,  184,
	208,  198,  213,  700,  197,  217,  184,  220,  215,  235,
	217,  223,  220,  224,  223,  228,  224,  240,  229,  231,
	228,  224,  229,  243,  231,  217,  241,  235,  240,  245,
	247,  244,  245,  250,  223,  247,  224,  241,  244,  260,
	284,  243,  269,  295,  280,  282,  296,  699,  235,  280,
	282,  297,  245,  283,  309,  283,  280,  282,  244,  309,
	250,  284,  243,  248,  295,  269,  260,  283,  313,  248,
	
	248,  331,  283,  296,  297,  313,  316,  248,  248,  283,
	321,  324,  341,  316,  698,  697,  248,  248,  248,  248,
	248,  248,  249,  348,  331,  321,  322,  336,  249,  249,
	339,  322,  336,  341,  349,  339,  249,  249,  324,  336,
	350,  340,  339,  340,  348,  249,  249,  249,  249,  249,
	249,  374,  372,  354,  383,  340,  424,  354,  354,  374,
	340,  349,  428,  350,  372,  375,  426,  340,  354,  429,
	375,  696,  429,  426,  374,  695,  694,  429,  426,  372,
	377,  383,  693,  424,  467,  428,  377,  377,  692,  468,
	691,  690,  429,  426,  377,  377,  467,  468,  689,  688,
	
	687,  686,  685,  377,  377,  377,  377,  377,  377,  378,
	684,  467,  468,  683,  682,  378,  378,  681,  680,  679,
	678,  677,  675,  378,  378,  674,  673,  672,  671,  669,
	668,  667,  378,  378,  378,  378,  378,  378,  379,  666,
	665,  663,  662,  661,  379,  379,  660,  659,  658,  657,
	656,  655,  379,  379,  654,  653,  652,  651,  650,  649,
	648,  379,  379,  379,  379,  379,  379,  380,  647,  646,
	645,  644,  643,  380,  380,  642,  641,  640,  639,  638,
	637,  380,  380,  636,  635,  634,  633,  632,  631,  630,
	380,  380,  380,  380,  380,  380,  381,  629,  626,  625,
	
	624,  623,  381,  381,  622,  621,  620,  619,  618,  617,
	381,  381,  616,  615,  614,  613,  612,  611,  610,  381,
	381,  381,  381,  381,  381,  382,  609,  606,  605,  604,
	603,  382,  382,  602,  601,  600,  599,  596,  595,  382,
	382,  594,  593,  592,  522,  515,  512,  500,  382,  382,
	382,  382,  382,  382,  431,  487,  486,  485,  481,  454,
	431,  431,  453,  451,  450,  449,  448,  447,  431,  431,
	444,  408,  407,  406,  405,  404,  403,  431,  431,  431,
	431,  431,  431,  432,  402,  401,  400,  399,  398,  432,
	432,  397,  385,  384,  376,  368,  358,  432,  432,  357,
	
	356,  347,  346,  345,  335,  333,  432,  432,  432,  432,
	432,  432,  433,  328,  320,  319,  318,  317,  433,  433,
	315,  314,  312,  307,  300,  294,  433,  433,  293,  289,
	279,  277,  264,  257,  255,  433,  433,  433,  433,  433,
	433,  434,  254,  253,  252,  246,  239,  434,  434,  238,
	237,  236,  227,  226,  225,  434,  434,  222,  221,  219,
	218,  216,  214,  212,  434,  434,  434,  434,  434,  434,
	435,  211,  210,  201,  195,  194,  435,  435,  190,  178,
	176,  163,  154,  148,  435,  435,  143,  141,  132,  127,
	125,  121,  120,  435,  435,  435,  435,  435,  435,  436,
	
	119,  116,  110,  105,  100,  436,  436,   98,   89,   84,
	82,   78,   77,  436,  436,   75,   73,   71,   60,   57,
	49,   48,  436,  436,  436,  436,  436,  436,  469,   46,
	40,   35,   33,   24,  469,  469,   19,   17,   13,    0,
	0,    0,  469,  469,    0,    0,    0,    0,    0,    0,
	0,  469,  469,  469,  469,  469,  469,  470,    0,    0,
	0,    0,    0,  470,  470,    0,    0,    0,    0,    0,
	0,  470,  470,    0,    0,    0,    0,    0,    0,    0,
	470,  470,  470,  470,  470,  470,  471,    0,    0,    0,
	0,    0,  471,  471,    0,    0,    0,    0,    0,    0,
	
	471,  471,    0,    0,    0,    0,    0,    0,    0,  471,
	471,  471,  471,  471,  471,  472,    0,    0,    0,    0,
	0,  472,  472,    0,    0,    0,    0,    0,    0,  472,
	472,    0,    0,    0,    0,    0,    0,    0,  472,  472,
	472,  472,  472,  472,  473,    0,    0,    0,    0,    0,
	473,  473,    0,    0,    0,    0,    0,    0,  473,  473,
	0,    0,    0,    0,    0,    0,    0,  473,  473,  473,
	473,  473,  473,  474,    0,    0,    0,    0,    0,  474,
	474,    0,    0,    0,    0,    0,    0,  474,  474,    0,
	0,    0,    0,    0,    0,    0,  474,  474,  474,  474,
	
	474,  474,  501,    0,    0,    0,    0,    0,  501,  501,
	0,    0,    0,    0,    0,    0,  501,  501,    0,    0,
	0,    0,    0,    0,    0,  501,  501,  501,  501,  501,
	501,  502,    0,    0,    0,    0,    0,  502,  502,    0,
	0,    0,    0,    0,    0,  502,  502,    0,    0,    0,
	0,    0,    0,    0,  502,  502,  502,  502,  502,  502,
	503,    0,    0,    0,    0,    0,  503,  503,    0,    0,
	0,    0,    0,    0,  503,  503,    0,    0,    0,    0,
	0,    0,    0,  503,  503,  503,  503,  503,  503,  504,
	0,    0,    0,    0,    0,  504,  504,    0,    0,    0,
	
	0,    0,    0,  504,  504,    0,    0,    0,    0,    0,
	0,    0,  504,  504,  504,  504,  504,  504,  505,    0,
	0,    0,    0,    0,  505,  505,    0,    0,    0,    0,
	0,    0,  505,  505,    0,    0,    0,    0,    0,    0,
	0,  505,  505,  505,  505,  505,  505,  506,    0,    0,
	0,    0,    0,  506,  506,    0,    0,    0,    0,    0,
	0,  506,  506,  506,  506,  506,    0,  506,    0,    0,
	506,  506,  506,  506,  506,  506,  506,  506,  506,  506,
	506,  506,  506,  506,  506,  506,  506,  506,  506,  526,
	0,    0,    0,    0,    0,  526,  526,    0,    0,    0,
	
	0,    0,    0,  526,  526,    0,    0,    0,    0,    0,
	0,    0,  526,  526,  526,  526,  526,  526,  527,    0,
	0,    0,    0,    0,  527,  527,    0,    0,    0,    0,
	0,    0,  527,  527,    0,    0,    0,    0,    0,    0,
	0,  527,  527,  527,  527,  527,  527,  528,    0,    0,
	0,    0,    0,  528,  528,    0,    0,    0,    0,    0,
	0,  528,  528,    0,    0,    0,    0,    0,    0,    0,
	528,  528,  528,  528,  528,  528,  539,    0,    0,    0,
	0,    0,  539,  539,    0,    0,    0,    0,    0,    0,
	539,  539,    0,    0,    0,    0,    0,    0,    0,  539,
	
	539,  539,  539,  539,  539,  540,    0,    0,    0,    0,
	0,  540,  540,    0,    0,    0,    0,    0,    0,  540,
	540,    0,    0,    0,    0,    0,    0,    0,  540,  540,
	540,  540,  540,  540,  541,    0,    0,    0,    0,    0,
	541,  541,    0,    0,    0,    0,    0,    0,  541,  541,
	0,    0,    0,    0,    0,    0,    0,  541,  541,  541,
	541,  541,  541,  551,    0,    0,    0,    0,    0,  551,
	551,    0,    0,    0,    0,    0,    0,  551,  551,    0,
	0,    0,    0,    0,    0,    0,  551,  551,  551,  551,
	551,  551,  552,    0,    0,    0,    0,    0,  552,  552,
	
	0,    0,    0,    0,    0,    0,  552,  552,    0,    0,
	0,    0,    0,    0,    0,  552,  552,  552,  552,  552,
	552,  553,    0,    0,    0,    0,    0,  553,  553,    0,
	0,    0,    0,    0,    0,  553,  553,    0,    0,    0,
	0,    0,    0,    0,  553,  553,  553,  553,  553,  553,
	562,    0,    0,    0,    0,    0,  562,  562,    0,    0,
	0,    0,    0,    0,  562,  562,    0,    0,    0,    0,
	0,    0,    0,  562,  562,  562,  562,  562,  562,  563,
	0,    0,    0,    0,    0,  563,  563,    0,    0,    0,
	0,    0,    0,  563,  563,    0,    0,    0,    0,    0,
	
	0,    0,  563,  563,  563,  563,  563,  563,  569,  569,
	569,  569,  569,  570,    0,  570,  570,  570,  571,    0,
	571,  571,  571,  572,  572,  572,  573,  573,  574,    0,
	574,  574,  574,  575,    0,  575,  575,  575,  576,    0,
	576,  576,  576,  577,    0,  577,  577,  577,  578,    0,
	578,  578,  578,  579,    0,  579,  579,  579,  580,    0,
	580,  580,  580,  581,    0,  581,  581,  581,  582,    0,
	582,  582,  582,  583,  583,  583,  584,  584,  585,    0,
	585,  585,  585,  586,    0,  586,  586,  586,  587,    0,
	587,  587,  587,  588,  588,  588,  589,  589,  590,    0,
	
	590,  590,  590,  591,    0,  591,  591,  591,  597,    0,
	597,  597,  597,  598,    0,  598,  598,  598,  607,    0,
	607,  607,  607,  608,    0,  608,  608,  608,  627,    0,
	627,  627,  627,  628,    0,  628,  628,  628,  664,  664,
	670,  670,  676,  676,  568,  568,  568,  568,  568,  568,
	568,  568,  568,  568,  568,  568,  568,  568,  568,  568,
	568,  568,  568,  568,  568,  568,  568,  568,  568,  568,
	568,  568,  568,  568,  568,  568,  568,  568,  568,  568,
	568,  568,  568,  568,  568,  568,  568,  568,  568,  568,
	568,  568,  568,  568,  568,  568,  568,  568,  568,  568,
	
	568,  568
} ;

static yy_state_type yy_last_accepting_state;
static YY_CHAR* yy_last_accepting_cpos;

#if YY_FogLexer_DEBUG != 0
static const short int yy_rule_linenum[90] = {
	0,
	163,  165,  166,  167,  168,  170,  171,  172,  174,  175,
	176,  181,  186,  187,  192,  193,  195,  196,  197,  199,
	200,  201,  202,  203,  204,  205,  206,  207,  208,  209,
	210,  211,  213,  218,  219,  221,  227,  228,  230,  237,
	244,  249,  250,  251,  252,  253,  254,  255,  256,  257,
	258,  259,  260,  261,  262,  263,  264,  265,  266,  267,
	268,  269,  270,  271,  272,  273,  274,  275,  276,  277,
	278,  279,  280,  281,  282,  283,  284,  285,  287,  288,
	294,  296,  298,  303,  304,  307,  308,  311,  312
} ;

#endif
/*  the intent behind this definition is that it'll catch
    any uses of REJECT which flex missed
*/
#define REJECT reject_used_but_not_detected
#define yymore() yymore_used_but_not_detected
#define YY_MORE_ADJ 0
#ifndef YY_USE_CLASS
	static yy_state_type yy_get_previous_state YY_PROTO(( void ));
	static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
#else
	#define yy_get_previous_state() ((yy_state_type)(yy_get_previous_state_()))
	#define yy_try_NUL_trans(c) ((yy_state_type)(yy_try_NUL_trans_(c)))
#endif

#ifndef YY_USE_CLASS
	#ifdef YY_FogLexer_LEX_DEFINED
		YY_FogLexer_LEX_RETURN YY_FogLexer_LEX ( YY_FogLexer_LEX_PARAM )
		YY_FogLexer_LEX_PARAM_DEF
	#else
		YY_DECL
	#endif
#else
	YY_FogLexer_LEX_RETURN YY_FogLexer_CLASS::YY_FogLexer_LEX ( YY_FogLexer_LEX_PARAM)
	
#endif
{
	yy_state_type yy_current_state;
	YY_FogLexer_CHAR* yy_cp, *yy_bp;
	int yy_act;
	
	/* % user's declarations go here */
	
	/****************************************************************************************************
	 			Comments
	 ****************************************************************************************************/
	/* % end of prolog */
	
	if ( yy_init ) {
		{
			YY_USER_INIT;
		}
		
		if ( ! yy_start )
			yy_start = 1;       /* first start state */
			
		if ( ! yy___in )
			yy___in = YY_FogLexer_IFILE_DEFAULT;
			
		if ( ! yy___out )
			yy___out = YY_FogLexer_OFILE_DEFAULT;
			
		if ( YY_FogLexer_CURRENT_BUFFER )
			YY_FogLexer_INIT_BUFFER( YY_FogLexer_CURRENT_BUFFER, yy___in );
		else
			YY_FogLexer_CURRENT_BUFFER = YY_FogLexer_CREATE_BUFFER( yy___in, YY_BUF_SIZE );
			
		YY_FogLexer_LOAD_BUFFER_STATE();
		yy_init = 0;
	}
	
	while ( 1 ) {       /* loops until end-of-file is reached */
		/* % yymore()-related code goes here */
		yy_cp = yy_c_buf_p;
		/* support of yy___text */
		*yy_cp = yy_hold_char;
		/*  yy_bp points to the position in yy_ch_buf of the start of the
		    current run.
		*/
		yy_bp = yy_cp;
		/* % code to set up and find next match goes here */
		yy_current_state = yy_start;
		
		if ( yy_bp[-1] == '\n' )
			++yy_current_state;
			
	yy_match:
	
		do {
			YY_CHAR yy_c = yy_ec[*yy_cp];
			
			if ( yy_accept[yy_current_state] ) {
				yy_last_accepting_state = yy_current_state;
				yy_last_accepting_cpos = yy_cp;
			}
			
			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state ) {
				yy_current_state = yy_def[yy_current_state];
				
				if ( yy_current_state >= 569 )
					yy_c = yy_meta[yy_c];
			}
			
			yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
			++yy_cp;
		} while ( yy_current_state != 568 );
		
		yy_cp = yy_last_accepting_cpos;
		yy_current_state = yy_last_accepting_state;
	yy_find_action:
		/* % code to find the action number goes here */
		yy_act = yy_accept[yy_current_state];
		YY_DO_BEFORE_ACTION;
		YY_USER_ACTION;
	do_action:      /* this label is used only to access EOF actions */
#if YY_FogLexer_DEBUG != 0
	
		if ( yy___flex_debug ) {
			if ( yy_act == 0 )
#ifndef YY_FogLexer_IOSTREAM
				fprintf( yy___stderr, "--scanner backtracking\n" );
				
#else
				yy___stderr << "--scanner backtracking" << endl;
#endif
			else if ( yy_act < YY_END_OF_BUFFER - 1 )
#ifndef YY_FogLexer_IOSTREAM
				fprintf( yy___stderr,
				         "--accepting rule at line %d (\"%s\")\n",
				         yy_rule_linenum[yy_act], yy___text );
				         
#else
				yy___stderr << "--accepting rule at line "
				            << (int)yy_rule_linenum[yy_act]
				            << " (\"" << (char*)yy___text << "\")" << endl;
#endif
			else if ( yy_act == YY_END_OF_BUFFER - 1 )
#ifndef YY_FogLexer_IOSTREAM
				fprintf( yy___stderr,
				         "--accepting default rule (\"%s\")\n",
				         yy___text );
				         
#else
				yy___stderr << "--accepting default rule"
				            << " (\"" << (char*)yy___text << "\")" << endl;
#endif
			else if ( yy_act == YY_END_OF_BUFFER )
#ifndef YY_FogLexer_IOSTREAM
				fprintf( yy___stderr, "--(end of buffer or a NUL)\n" );
				
#else
				yy___stderr << "--(end of buffer or a NUL)" << endl;
#endif
			else
#ifndef YY_FogLexer_IOSTREAM
				fprintf( yy___stderr, "--EOF\n" );
				
#else
				yy___stderr << "--EOF" << endl;
#endif
		}
		
#endif
		
		switch ( yy_act ) {
		/* % actions go here */
		case 0: /* must backtrack */
			/* undo the effects of YY_DO_BEFORE_ACTION */
			*yy_cp = yy_hold_char;
			yy_cp = yy_last_accepting_cpos;
			yy_current_state = yy_last_accepting_state;
			goto yy_find_action;
			
		case 1: {
			begin(*_pre_comment_state);
			yyValue = FogTokenType::get_character(' '); return true;
		}
		
		YY_BREAK
		
		case 2:
		case 3:
		{ advance_token(yyleng); }
		
		YY_BREAK
		
		case 4:
		case 5:
		{ advance_line(); }
		
		YY_BREAK
		
		case 6:
		case 7:
		case 8:
		{ advance_token(yyleng); }
		
		YY_BREAK
		
		case 9:
		case 10:
		case 11:
		{ advance_token(yyleng); _pre_comment_state = &begin(comment_state); }
		
		YY_BREAK
		
		/****************************************************************************************************
		 			#, #error and #pragma pass all. ({pp_token}|{pp_ws})* unfortunately is more than flex++ can take.
		 ****************************************************************************************************/
		case 12:
		{ yyValue = FogTokenType::make_literal_string(text(), yyleng); return true; }
		
		YY_BREAK
		
		/****************************************************************************************************
		 			#include requires distinct recognition of ".." and <...>
		 ****************************************************************************************************/
		case 13:
		case 14:
		{ got_string(yyValue, text() + 1, yyleng - 2, false); return true; }
		
		YY_BREAK
		
		/****************************************************************************************************
		 			# Directives			.bugbug comment preceeding # is not ignored.
		 ****************************************************************************************************/
		case 15:
		case 16: {
			CONDMSG(Fog::debug_lex(), "<LEXER-" << _state->_name << "> \""  << text() << '"');
			advance_token(yyleng); begin(hash_state);
		}
		
		YY_BREAK
		
		case 17:
		case 18:
		case 19: {
			CONDMSG(Fog::debug_lex(), "<LEXER-" << _state->_name << "> \""  << text() << '"');
			advance_token(yyleng);
		}
		
		YY_BREAK
		
		case 20:
		{ yyValue = FogTokenType::get(FogTokenType::HASH_DEFINE); begin(initial_state); return true; }
		
		YY_BREAK
		
		case 21:
		{ yyValue = FogTokenType::get(FogTokenType::HASH_ELIF); begin(initial_state); return true; }
		
		YY_BREAK
		
		case 22:
		{ yyValue = FogTokenType::get(FogTokenType::HASH_ELSE); begin(initial_state); return true; }
		
		YY_BREAK
		
		case 23:
		{ yyValue = FogTokenType::get(FogTokenType::HASH_ENDIF); begin(initial_state); return true; }
		
		YY_BREAK
		
		case 24:
		{ yyValue = FogTokenType::get(FogTokenType::HASH_ERROR); begin(initial_state); return true; }
		
		YY_BREAK
		
		case 25:
		{ yyValue = FogTokenType::get(FogTokenType::HASH_IF); begin(initial_state); return true; }
		
		YY_BREAK
		
		case 26:
		{ yyValue = FogTokenType::get(FogTokenType::HASH_IFDEF); begin(initial_state); return true; }
		
		YY_BREAK
		
		case 27:
		{ yyValue = FogTokenType::get(FogTokenType::HASH_IFNDEF); begin(initial_state); return true; }
		
		YY_BREAK
		
		case 28:
		{ yyValue = FogTokenType::get(FogTokenType::HASH_INCLUDE); begin(initial_state); return true; }
		
		YY_BREAK
		
		case 29:
		{ yyValue = FogTokenType::get(FogTokenType::HASH_LINE); begin(initial_state); return true; }
		
		YY_BREAK
		
		case 30:
		{ yyValue = FogTokenType::get(FogTokenType::HASH_PRAGMA); begin(initial_state); return true; }
		
		YY_BREAK
		
		case 31:
		{ yyValue = FogTokenType::get(FogTokenType::HASH_UNDEF); begin(initial_state); return true; }
		
		YY_BREAK
		
		case 32: {
			yyless(0);
			yyValue = FogTokenType::get(FogTokenType::HASH_BLANK); begin(initial_state); return true;
		}
		
		YY_BREAK
		
		case 33:
		{ yyValue = FogTokenType::get(FogTokenType::HASH_BLANK); begin(initial_state); return true; }
		
		YY_BREAK
		
		/****************************************************************************************************
		 			Character literals
		 ****************************************************************************************************/
		case 34:
		{ got_character(yyValue, text(), yyleng - 1); return true; }
		
		YY_BREAK
		
		case 35: {
			ERRMSG("End of line assumed to terminate character with trailing escape.");
			got_character(yyValue, text(), yyleng - 1); return true;
		}
		
		YY_BREAK
		
		case 36: {
			ERRMSG("End of line assumed to terminate character.");
			got_character(yyValue, text(), yyleng); return true;
		}
		
		YY_BREAK
		
		/****************************************************************************************************
		 			String literals
		 ****************************************************************************************************/
		case 37:
		{ got_string(yyValue, text(), yyleng - 1, true); return true; }
		
		YY_BREAK
		
		case 38: {
			ERRMSG("End of line assumed to terminate string with trailing escape.");
			got_string(yyValue, text(), yyleng - 1, true); return true;
		}
		
		YY_BREAK
		
		case 39: {
			ERRMSG("End of line assumed to terminate string.");
			got_string(yyValue, text(), yyleng, true); return true;
		}
		
		YY_BREAK
		
		/****************************************************************************************************
		 			Number literals
		 			'0' is special cased in FogNumber::token_type_enum
		 ****************************************************************************************************/
		case 40:
		{ yyValue = FogTokenType::make_number(text(), yyleng); return true; }
		
		YY_BREAK
		
		/****************************************************************************************************
		 			Identifiers
		 				DEFINED is detected where allowable by FogHashParser
		 				Id (and MacroId) are partitioned into MetaType, BuiltIn, keywords in FogLexerGarbage
		 ****************************************************************************************************/
		case 41:
		{ yyValue.assign(FogTokenType::make_identifier(text(), yyleng)); return true; }
		
		YY_BREAK
		
		/****************************************************************************************************
		 			Punctuation
		 ****************************************************************************************************/
		case 42:
		{ yyValue = FogTokenType::get_character('#'); return true; }
		
		YY_BREAK
		
		case 43:
		{ yyValue = FogTokenType::get(FogTokenType::DI_HASH); return true; }
		
		YY_BREAK
		
		case 44:
		{ yyValue = FogTokenType::get(FogTokenType::HASH_HASH); return true; }
		
		YY_BREAK
		
		case 45:
		{ yyValue = FogTokenType::get(FogTokenType::DI_HASH_HASH); return true; }
		
		YY_BREAK
		
		case 46:
		{ yyValue = FogTokenType::make_open_brace(detabbed_col() + 1); return true; }
		
		YY_BREAK
		
		case 47:
		{ yyValue = FogTokenType::make_di_open_brace(detabbed_col() + 2); return true; }
		
		YY_BREAK
		
		case 48:
		{ yyValue = FogTokenType::get_character('['); return true; }
		
		YY_BREAK
		
		case 49:
		{ yyValue = FogTokenType::get(FogTokenType::DI_SQUARE); return true; }
		
		YY_BREAK
		
		case 50:
		{ yyValue = FogTokenType::get_character('}'); return true; }
		
		YY_BREAK
		
		case 51:
		{ yyValue = FogTokenType::get(FogTokenType::DI_ECARB); return true; }
		
		YY_BREAK
		
		case 52:
		{ yyValue = FogTokenType::get_character(']'); return true; }
		
		YY_BREAK
		
		case 53:
		{ yyValue = FogTokenType::get(FogTokenType::DI_ERAUQS); return true; }
		
		YY_BREAK
		
		case 54:
		{ yyValue = FogTokenType::get(FogTokenType::SCOPE); return true; }
		
		YY_BREAK
		
		case 55:
		{ yyValue = FogTokenType::get(FogTokenType::ELLIPSIS); return true; }
		
		YY_BREAK
		
		case 56:
		{ yyValue = FogTokenType::get(FogTokenType::SHL); return true; }
		
		YY_BREAK
		
		case 57:
		{ yyValue = FogTokenType::get(FogTokenType::SHR); return true; }
		
		YY_BREAK
		
		case 58:
		{ yyValue = FogTokenType::get(FogTokenType::EQ); return true; }
		
		YY_BREAK
		
		case 59:
		{ yyValue = FogTokenType::get(FogTokenType::NE); return true; }
		
		YY_BREAK
		
		case 60:
		{ yyValue = FogTokenType::get(FogTokenType::LE); return true; }
		
		YY_BREAK
		
		case 61:
		{ yyValue = FogTokenType::get(FogTokenType::GE); return true; }
		
		YY_BREAK
		
		case 62:
		{ yyValue = FogTokenType::get(FogTokenType::LOG_AND); return true; }
		
		YY_BREAK
		
		case 63:
		{ yyValue = FogTokenType::get(FogTokenType::LOG_OR); return true; }
		
		YY_BREAK
		
		case 64:
		{ yyValue = FogTokenType::get(FogTokenType::INC); return true; }
		
		YY_BREAK
		
		case 65:
		{ yyValue = FogTokenType::get(FogTokenType::DEC); return true; }
		
		YY_BREAK
		
		case 66:
		{ yyValue = FogTokenType::get(FogTokenType::ARROW_STAR); return true; }
		
		YY_BREAK
		
		case 67:
		{ yyValue = FogTokenType::get(FogTokenType::ARROW); return true; }
		
		YY_BREAK
		
		case 68:
		{ yyValue = FogTokenType::get(FogTokenType::DOT_STAR); return true; }
		
		YY_BREAK
		
		case 69:
		{ yyValue = FogTokenType::get(FogTokenType::ASS_ADD); return true; }
		
		YY_BREAK
		
		case 70:
		{ yyValue = FogTokenType::get(FogTokenType::ASS_SUB); return true; }
		
		YY_BREAK
		
		case 71:
		{ yyValue = FogTokenType::get(FogTokenType::ASS_MUL); return true; }
		
		YY_BREAK
		
		case 72:
		{ yyValue = FogTokenType::get(FogTokenType::ASS_DIV); return true; }
		
		YY_BREAK
		
		case 73:
		{ yyValue = FogTokenType::get(FogTokenType::ASS_MOD); return true; }
		
		YY_BREAK
		
		case 74:
		{ yyValue = FogTokenType::get(FogTokenType::ASS_XOR); return true; }
		
		YY_BREAK
		
		case 75:
		{ yyValue = FogTokenType::get(FogTokenType::ASS_AND); return true; }
		
		YY_BREAK
		
		case 76:
		{ yyValue = FogTokenType::get(FogTokenType::ASS_OR); return true; }
		
		YY_BREAK
		
		case 77:
		{ yyValue = FogTokenType::get(FogTokenType::ASS_SHR); return true; }
		
		YY_BREAK
		
		case 78:
		{ yyValue = FogTokenType::get(FogTokenType::ASS_SHL); return true; }
		
		YY_BREAK
		
		case 79:
		case 80: {
			yyValue = FogTokenType::make_literal_character(text(), yyleng);
			return true;
		}
		
		YY_BREAK
		
		/****************************************************************************************************
		 			Whitespace, Single Characters and New Lines
		 ****************************************************************************************************/
		case 81: {
			yyValue = FogTokenType::make_spacing(columns(yytext, yyleng));
			return true;
		}
		
		YY_BREAK
		
		case 82: {
			yyValue = FogTokenType::get_character(yytext[0]);
			return true;
		}
		
		YY_BREAK
		
		case 83:
		{ yyValue = current_line(); return true; }
		
		YY_BREAK
		
		/****************************************************************************************************
		 			Backstops
		 ****************************************************************************************************/
		case 84:
		case 85: {
			ERRMSG("BUG - Unexpected token " << c_string(text(), yyleng) << " in "
			       << state()); yyValue = FogTokenType::nil(); return true;
		}
		
		YY_BREAK
		
		case 86:
		case 87: {
			ERRMSG("BUG - Unexpected character " << c_string(yytext[0]) << " in "
			       << state()); yyValue = FogTokenType::nil(); return true;
		}
		
		YY_BREAK
		
		case 88:
		case 89: {
			ERRMSG("BUG - Unexpected end of line in " << state_name());
			advance_line(); yyValue = FogTokenType::nil(); return true;
		}
		
		YY_BREAK
		
		case 90:
			ECHO;
			YY_BREAK
			
		case YY_STATE_EOF(INITIAL):
		case YY_STATE_EOF(COMMENT_STATE):
		case YY_STATE_EOF(INCLUDE_STATE):
		case YY_STATE_EOF(SOAK_STATE):
		case YY_STATE_EOF(HASH_STATE):
		case YY_STATE_EOF(OFF_STATE):
			yyterminate();
			
		case YY_END_OF_BUFFER: {
			/* amount of text matched not including the EOB char */
			int yy_amount_of_matched_text = yy_cp - yy___text - 1;
			/* undo the effects of YY_DO_BEFORE_ACTION */
			*yy_cp = yy_hold_char;
			
			/*  note that here we test for yy_c_buf_p "<=" to the position
			    of the first EOB in the buffer, since yy_c_buf_p will
			    already have been incremented past the NUL character
			    (since all states make transitions on EOB to the end-
			    of-buffer state).  Contrast this with the test in yyinput().
			*/
			if ( yy_c_buf_p <= &YY_FogLexer_CURRENT_BUFFER->yy_ch_buf[yy_n_chars] )
				/* this was really a NUL */
			{
				yy_state_type yy_next_state;
				yy_c_buf_p = yy___text + yy_amount_of_matched_text;
				yy_current_state = yy_get_previous_state();
				/*  okay, we're now positioned to make the
				    NUL transition.  We couldn't have
				    yy_get_previous_state() go ahead and do it
				    for us because it doesn't know how to deal
				    with the possibility of jamming (and we
				    don't want to build jamming into it because
				    then it will run more slowly)
				*/
				yy_next_state = yy_try_NUL_trans( yy_current_state );
				yy_bp = yy___text + YY_MORE_ADJ;
				
				if ( yy_next_state ) {
					/* consume the NUL */
					yy_cp = ++yy_c_buf_p;
					yy_current_state = yy_next_state;
					goto yy_match;
				}
				else {
					/* % code to do backtracking for compressed tables and set up yy_cp goes here */
					yy_cp = yy_last_accepting_cpos;
					yy_current_state = yy_last_accepting_state;
					goto yy_find_action;
				}
			}
			else switch ( yy_get_next_buffer() ) {
				case EOB_ACT_END_OF_FILE: {
					yy_did_buffer_switch_on_eof = 0;
					
					if ( yywrap() ) {
						/*  note: because we've taken care in
						    yy_get_next_buffer() to have set up yy___text,
						    we can now set up yy_c_buf_p so that if some
						    total hoser (like flex itself) wants
						    to call the scanner after we return the
						    YY_NULL, it'll still work - another YY_NULL
						    will get returned.
						*/
						yy_c_buf_p = yy___text + YY_MORE_ADJ;
						yy_act = YY_STATE_EOF((yy_start - 1) / 2);
						goto do_action;
					}
					else {
						if ( ! yy_did_buffer_switch_on_eof )
							YY_NEW_FILE;
					}
				}
				break;
				
				case EOB_ACT_CONTINUE_SCAN:
					yy_c_buf_p = yy___text + yy_amount_of_matched_text;
					yy_current_state = yy_get_previous_state();
					yy_cp = yy_c_buf_p;
					yy_bp = yy___text + YY_MORE_ADJ;
					goto yy_match;
					
				case EOB_ACT_LAST_MATCH:
					yy_c_buf_p =
					        &YY_FogLexer_CURRENT_BUFFER->yy_ch_buf[yy_n_chars];
					yy_current_state = yy_get_previous_state();
					yy_cp = yy_c_buf_p;
					yy_bp = yy___text + YY_MORE_ADJ;
					goto yy_find_action;
				}
				
			break;
		}
		
		default:
#if YY_FogLexer_DEBUG != 0
#ifndef YY_FogLexer_IOSTREAM
			fprintf(yy___stderr, "action # %d\n", yy_act );
#else
			yy___stderr << "action # " << (int)yy_act << endl;
#endif
#endif
			YY_FATAL_ERROR(
			        "fatal flex scanner internal error--no action found" );
		}
	}
	
	yyterminate();/* avoid the no return value error message on MS-C7/dos */
}


/*  yy_get_next_buffer - try to read in a new buffer

    synopsis
       int yy_get_next_buffer();

    returns a code representing an action
       EOB_ACT_LAST_MATCH -
       EOB_ACT_CONTINUE_SCAN - continue scanning from current position
       EOB_ACT_END_OF_FILE - end of file
*/
#ifndef YY_USE_CLASS
	static int yy_get_next_buffer()
#else
	int YY_FogLexer_CLASS::yy_get_next_buffer()
#endif
{
	YY_FogLexer_CHAR* dest = YY_FogLexer_CURRENT_BUFFER->yy_ch_buf;
	YY_FogLexer_CHAR* source = yy___text - 1; /* copy prev. char, too */
	int number_to_move, i;
	int ret_val;
	
	if ( yy_c_buf_p > &YY_FogLexer_CURRENT_BUFFER->yy_ch_buf[yy_n_chars + 1] )
		YY_FATAL_ERROR(
		        "fatal flex scanner internal error--end of buffer missed" );
		        
	/* try to read more data */
	/* first move last chars to start of buffer */
	number_to_move = yy_c_buf_p - yy___text;
	
	for ( i = 0; i < number_to_move; ++i )
		*(dest++) = *(source++);
		
	if ( YY_FogLexer_CURRENT_BUFFER->yy_eof_status != EOF_NOT_SEEN )
		/*  don't do the read, it's not guaranteed to return an EOF,
		    just force an EOF
		*/
		yy_n_chars = 0;
	else {
		int num_to_read = YY_FogLexer_CURRENT_BUFFER->yy_buf_size - number_to_move - 1;
		
		if ( num_to_read > YY_READ_BUF_SIZE )
			num_to_read = YY_READ_BUF_SIZE;
		else if ( num_to_read <= 0 )
			YY_FATAL_ERROR( "fatal error - scanner input buffer overflow" );
			
		/* read in more data */
		YY_INPUT( (&YY_FogLexer_CURRENT_BUFFER->yy_ch_buf[number_to_move]),
		          yy_n_chars, num_to_read );
	}
	
	if ( yy_n_chars == 0 ) {
		if ( number_to_move - YY_MORE_ADJ == 1 ) {
			ret_val = EOB_ACT_END_OF_FILE;
			YY_FogLexer_CURRENT_BUFFER->yy_eof_status = EOF_DONE;
		}
		else {
			ret_val = EOB_ACT_LAST_MATCH;
			YY_FogLexer_CURRENT_BUFFER->yy_eof_status = EOF_PENDING;
		}
	}
	else
		ret_val = EOB_ACT_CONTINUE_SCAN;
		
	yy_n_chars += number_to_move;
	YY_FogLexer_CURRENT_BUFFER->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
	YY_FogLexer_CURRENT_BUFFER->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
	/*  yy___text begins at the second character in yy_ch_buf; the first
	    character is the one which preceded it before reading in the latest
	    buffer; it needs to be kept around in case it's a newline, so
	    yy_get_previous_state() will have with '^' rules active
	*/
	yy___text = &YY_FogLexer_CURRENT_BUFFER->yy_ch_buf[1];
	return ( ret_val );
}


/*  yy_get_previous_state - get the state just before the EOB char was reached

    synopsis
       yy_state_type yy_get_previous_state();
*/

#ifndef YY_USE_CLASS
	static yy_state_type yy_get_previous_state()
#else
	long YY_FogLexer_CLASS::yy_get_previous_state_()
#endif
{
	yy_state_type yy_current_state;
	YY_FogLexer_CHAR* yy_cp;
	/* % code to get the start state into yy_current_state goes here */
	YY_CHAR* yy_bp = yy___text;
	yy_current_state = yy_start;
	
	if ( yy_bp[-1] == '\n' )
		++yy_current_state;
		
	for ( yy_cp = yy___text + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp ) {
		/* % code to find the next state goes here */
		YY_CHAR yy_c = (*yy_cp ? yy_ec[*yy_cp] : 1);
		
		if ( yy_accept[yy_current_state] ) {
			yy_last_accepting_state = yy_current_state;
			yy_last_accepting_cpos = yy_cp;
		}
		
		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state ) {
			yy_current_state = yy_def[yy_current_state];
			
			if ( yy_current_state >= 569 )
				yy_c = yy_meta[yy_c];
		}
		
		yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
	}
	
#ifndef YY_USE_CLASS
	return ( yy_current_state );
#else
	return (long)( yy_current_state );
#endif
}


/*  yy_try_NUL_trans - try to make a transition on the NUL character

    synopsis
       next_state = yy_try_NUL_trans( current_state );
*/

#ifndef YY_USE_CLASS
	#ifdef YY_USE_PROTOS
		static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )
	#else
		static yy_state_type yy_try_NUL_trans( yy_current_state )
		register yy_state_type yy_current_state;
	#endif
#else
	long YY_FogLexer_CLASS::yy_try_NUL_trans_(long yy_current_state_)
#endif

{
#ifndef YY_USE_CLASS
#else
	yy_state_type yy_current_state = (yy_state_type)yy_current_state_;
#endif
	int yy_is_jam;
	/* % code to find the next state, and perhaps do backtracking, goes here */
	YY_CHAR* yy_cp = yy_c_buf_p;
	YY_CHAR yy_c = 1;
	
	if ( yy_accept[yy_current_state] ) {
		yy_last_accepting_state = yy_current_state;
		yy_last_accepting_cpos = yy_cp;
	}
	
	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state ) {
		yy_current_state = yy_def[yy_current_state];
		
		if ( yy_current_state >= 569 )
			yy_c = yy_meta[yy_c];
	}
	
	yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
	yy_is_jam = (yy_current_state == 568);
#ifndef YY_USE_CLASS
	return ( yy_is_jam ? 0 : yy_current_state );
#else
	return (long)( yy_is_jam ? 0 : yy_current_state );
#endif
}

#ifndef YY_USE_CLASS
	#ifdef YY_USE_PROTOS
		static void yyunput( YY_FogLexer_CHAR c, YY_FogLexer_CHAR* yy_bp )
	#else
		static void yyunput( c, yy_bp )
		YY_FogLexer_CHAR c;
		YY_FogLexer_CHAR* yy_bp;
	#endif
#else
	void YY_FogLexer_CLASS::yyunput( YY_FogLexer_CHAR c, YY_FogLexer_CHAR* yy_bp )
#endif

{
	YY_FogLexer_CHAR* yy_cp = yy_c_buf_p;
	/* undo effects of setting up yy___text */
	*yy_cp = yy_hold_char;
	
	if ( yy_cp < YY_FogLexer_CURRENT_BUFFER->yy_ch_buf + 2 ) {
		/* need to shift things up to make room */
		int number_to_move = yy_n_chars + 2; /* +2 for EOB chars */
		YY_FogLexer_CHAR* dest =
		        &YY_FogLexer_CURRENT_BUFFER->yy_ch_buf[YY_FogLexer_CURRENT_BUFFER->yy_buf_size + 2];
		YY_FogLexer_CHAR* source =
		        &YY_FogLexer_CURRENT_BUFFER->yy_ch_buf[number_to_move];
		        
		while ( source > YY_FogLexer_CURRENT_BUFFER->yy_ch_buf )
			*--dest = *--source;
			
		yy_cp += dest - source;
		yy_bp += dest - source;
		yy_n_chars = YY_FogLexer_CURRENT_BUFFER->yy_buf_size;
		
		if ( yy_cp < YY_FogLexer_CURRENT_BUFFER->yy_ch_buf + 2 )
			YY_FATAL_ERROR( "flex scanner push-back overflow" );
	}
	
	if ( yy_cp > yy_bp && yy_cp[-1] == '\n' )
		yy_cp[-2] = '\n';
		
	*--yy_cp = c;
	/*  note: the formal parameter *must* be called "yy_bp" for this
	         macro to now work correctly
	*/
	YY_DO_BEFORE_ACTION; /* set up yy___text again */
}

#ifndef YY_USE_CLASS
	#ifdef __cplusplus
		static int yyinput()
	#else
		static int input()
	#endif
#else
	int YY_FogLexer_CLASS::input()
#endif
{
	int c;
	YY_FogLexer_CHAR* yy_cp = yy_c_buf_p;
	*yy_cp = yy_hold_char;
	
	if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR ) {
		/*  yy_c_buf_p now points to the character we want to return.
		    If this occurs *before* the EOB characters, then it's a
		    valid NUL; if not, then we've hit the end of the buffer.
		*/
		if ( yy_c_buf_p < &YY_FogLexer_CURRENT_BUFFER->yy_ch_buf[yy_n_chars] )
			/* this was really a NUL */
			*yy_c_buf_p = '\0';
		else {
			/* need more input */
			yy___text = yy_c_buf_p;
			++yy_c_buf_p;
			
			switch ( yy_get_next_buffer() ) {
			case EOB_ACT_END_OF_FILE: {
				if ( yywrap() ) {
					yy_c_buf_p = yy___text + YY_MORE_ADJ;
					return ( EOF );
				}
				
				YY_NEW_FILE;
#ifndef YY_USE_CLASS
#ifdef __cplusplus
				return ( yyinput() );
#else
				return ( input() );
#endif
#else
				return ( input() );
#endif
			}
			break;
			
			case EOB_ACT_CONTINUE_SCAN:
				yy_c_buf_p = yy___text + YY_MORE_ADJ;
				break;
				
			case EOB_ACT_LAST_MATCH:
#ifndef YY_USE_CLASS
#ifdef __cplusplus
				YY_FATAL_ERROR( "unexpected last match in yyinput()" );
#else
				YY_FATAL_ERROR( "unexpected last match in input()" );
#endif
#else
				YY_FATAL_ERROR( "unexpected last match in YY_FogLexer_CLASS::input()" );
#endif
			}
		}
	}
	
	c = *yy_c_buf_p;
	yy_hold_char = *++yy_c_buf_p;
	return ( c );
}


#ifndef YY_USE_CLASS
	#ifdef YY_USE_PROTOS
		void YY_FogLexer_RESTART( YY_FogLexer_IFILE*  input_file )
	#else
		void YY_FogLexer_RESTART( input_file )
		YY_FogLexer_IFILE*  input_file;
	#endif
#else
	void YY_FogLexer_CLASS::YY_FogLexer_RESTART ( YY_FogLexer_IFILE*  input_file )
#endif

{
	YY_FogLexer_INIT_BUFFER( YY_FogLexer_CURRENT_BUFFER, input_file );
	YY_FogLexer_LOAD_BUFFER_STATE();
}


#ifndef YY_USE_CLASS
	#ifdef YY_USE_PROTOS
		void YY_FogLexer_SWITCH_TO_BUFFER( YY_BUFFER_STATE new_buffer )
	#else
		void YY_FogLexer_SWITCH_TO_BUFFER( new_buffer )
		YY_BUFFER_STATE new_buffer;
	#endif
#else
	void YY_FogLexer_CLASS::YY_FogLexer_SWITCH_TO_BUFFER( YY_BUFFER_STATE new_buffer )
#endif

{
	if ( YY_FogLexer_CURRENT_BUFFER == new_buffer )
		return;
		
	if ( YY_FogLexer_CURRENT_BUFFER ) {
		/* flush out information for old buffer */
		*yy_c_buf_p = yy_hold_char;
		YY_FogLexer_CURRENT_BUFFER->yy_buf_pos = yy_c_buf_p;
		YY_FogLexer_CURRENT_BUFFER->yy_n_chars = yy_n_chars;
	}
	
	YY_FogLexer_CURRENT_BUFFER = new_buffer;
	YY_FogLexer_LOAD_BUFFER_STATE();
	/*  we don't actually know whether we did this switch during
	    EOF (yywrap()) processing, but the only time this flag
	    is looked at is after yywrap() is called, so it's safe
	    to go ahead and always set it.
	*/
	yy_did_buffer_switch_on_eof = 1;
}


#ifndef YY_USE_CLASS
	#ifdef YY_USE_PROTOS
		void YY_FogLexer_LOAD_BUFFER_STATE( void )
	#else
		void YY_FogLexer_LOAD_BUFFER_STATE()
	#endif
#else
	void YY_FogLexer_CLASS::YY_FogLexer_LOAD_BUFFER_STATE(  )
#endif

{
	yy_n_chars = YY_FogLexer_CURRENT_BUFFER->yy_n_chars;
	yy___text = yy_c_buf_p = YY_FogLexer_CURRENT_BUFFER->yy_buf_pos;
	yy___in = YY_FogLexer_CURRENT_BUFFER->yy_input_file;
	yy_hold_char = *yy_c_buf_p;
}


#ifndef YY_USE_CLASS
	#ifdef YY_USE_PROTOS
		YY_BUFFER_STATE YY_FogLexer_CREATE_BUFFER( YY_FogLexer_IFILE*  file, int size )
	#else
		YY_BUFFER_STATE YY_FogLexer_CREATE_BUFFER( file, size )
		YY_FogLexer_IFILE*  file;
		int size;
	#endif
#else
	YY_BUFFER_STATE YY_FogLexer_CLASS::YY_FogLexer_CREATE_BUFFER( YY_FogLexer_IFILE*  file, int size )
#endif

{
	YY_BUFFER_STATE b;
	b = (YY_BUFFER_STATE) malloc( sizeof( struct yy_buffer_state ) );
	
	if ( ! b )
		YY_FATAL_ERROR( "out of dynamic memory in YY_FogLexer_CREATE_BUFFER()" );
		
	b->yy_buf_size = size;
	/*  yy_ch_buf has to be 2 characters longer than the size given because
	    we need to put in 2 end-of-buffer characters.
	*/
	b->yy_ch_buf = (YY_FogLexer_CHAR*) malloc( (unsigned) (b->yy_buf_size + 2) );
	
	if ( ! b->yy_ch_buf )
		YY_FATAL_ERROR( "out of dynamic memory in YY_FogLexer_CREATE_BUFFER()" );
		
	YY_FogLexer_INIT_BUFFER( b, file );
	return ( b );
}


#ifndef YY_USE_CLASS
	#ifdef YY_USE_PROTOS
		void YY_FogLexer_DELETE_BUFFER( YY_BUFFER_STATE b )
	#else
		void YY_FogLexer_DELETE_BUFFER( b )
		YY_BUFFER_STATE b;
	#endif
#else
	void YY_FogLexer_CLASS::YY_FogLexer_DELETE_BUFFER( YY_BUFFER_STATE b )
#endif

{
	if ( b == YY_FogLexer_CURRENT_BUFFER )
		YY_FogLexer_CURRENT_BUFFER = (YY_BUFFER_STATE) 0;
		
	free( (char*) b->yy_ch_buf );
	free( (char*) b );
}


#ifndef YY_USE_CLASS
	#ifdef YY_USE_PROTOS
		void YY_FogLexer_INIT_BUFFER( YY_BUFFER_STATE b, YY_FogLexer_IFILE*  file )
	#else
		void YY_FogLexer_INIT_BUFFER( b, file )
		YY_BUFFER_STATE b;
		YY_FogLexer_IFILE*  file;
	#endif
#else
	void YY_FogLexer_CLASS::YY_FogLexer_INIT_BUFFER( YY_BUFFER_STATE b, YY_FogLexer_IFILE*  file)
#endif

{
	b->yy_input_file = file;
	/*  we put in the '\n' and start reading from [1] so that an
	    initial match-at-newline will be true.
	*/
	b->yy_ch_buf[0] = '\n';
	b->yy_n_chars = 1;
	/*  we always need two end-of-buffer characters.  The first causes
	    a transition to the end-of-buffer state.  The second causes
	    a jam in that state.
	*/
	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
	b->yy_ch_buf[2] = YY_END_OF_BUFFER_CHAR;
	b->yy_buf_pos = &b->yy_ch_buf[1];
	b->yy_eof_status = EOF_NOT_SEEN;
}

TYPEINFO_SINGLE(FogLexer, Super)

const FogLexerState FogLexer::comment_state = { "<COMMENT>", COMMENT_STATE };
const FogLexerState FogLexer::hash_state = { "<HASH>", HASH_STATE };
const FogLexerState FogLexer::include_state = { "<INCLUDE>", INCLUDE_STATE };
const FogLexerState FogLexer::initial_state = { "<INITIAL>", INITIAL };
const FogLexerState FogLexer::off_state = { "<OFF>", OFF_STATE };
const FogLexerState FogLexer::soak_state = { "<SOAK>", SOAK_STATE };

size_t FogLexer::_tokens = 0;
size_t FogLexer::_body_tokens = 0;

#include <Fog/FogIncludeAll.h>

//
//	Change lexing state to aState, invoking BEGIN appropriately. Returns the previous state.
//
const FogLexerState& FogLexer::begin(const FogLexerState& aState) {
	const FogLexerState& oldState = state();
	_state = &aState;
	BEGIN(state()._state);
	return oldState;
}

//
//	Return the number of source character columns contributed by aString[aSize].
//
size_t FogLexer::columns(const char* aString, size_t aSize) {
	const char* p = aString;
	size_t tabSize = Fog::get_tab_size();
	size_t detabbedCol = detabbed_col();
	
	for (size_t i = aSize; i > 0; i--, p++) {
		if (*p == '\t') {
			size_t numTabs = detabbedCol / tabSize;
			detabbedCol = (numTabs + 1) * tabSize;
		}
		else
			detabbedCol++;
	}
	
	long aValue = detabbedCol - detabbed_col();
	return aValue;
}

//
//	Return the next token from the lexer.
//
const char* FogLexer::get(FogTokenContext& tokenContext) {
	advance_line();
	//	if ((yyleng != 1) || (yytext[0] != '\n'))
	//		advance(yyleng, columns(yytext, yyleng));
	const FogLexerState* preState = _state;
	
	if (!yylex(tokenContext.value())) {
		tokenContext.reset();
		return 0;
	}
	
	tokenContext.set_line(current_line(), detabbed_col());
	
	if (!tokenContext.token().is_white())
		_tokens++;
		
	//	advance_line();
	if ((yyleng != 1) || (yytext[0] != '\n'))
		advance_token(columns(yytext, yyleng));
	else
		advance_token(0);
		
	CONDMSG(Fog::debug_lex(), "<LEXER-" << preState->_name << "> " << _state->_name << " : " << tokenContext);
	return "<LEXER-GET>";
}

//
//	Configure the lexer to reflect successful parsing of a character value, assigning it to yyValue.
//
//	The source someText[aLength] should correspond to the parsed text including any L or ' prefix
//	but excluding any ' suffix. In this way the return can indicate whether a wide character has
//	been detected and the routine can accommodate a variety of erroneous terminations.
//
void FogLexer::got_character(FogTokenRef& yyValue, const char* someText, size_t aLength) {
	bool isWide = false;
	
	if (someText && aLength) {
		if (*someText == 'L') {
			isWide = true;
			someText++;
			aLength--;
		}
		
		if (!aLength || (*someText != '\''))
			ERRMSG("BUG - bad start of character literal.");
			
		if (aLength) {
			someText++;
			aLength--;
		}
	}
	
	if (isWide)
		yyValue = FogTokenType::make_wide_character(someText, aLength);
	else
		yyValue = FogTokenType::make_narrow_character(someText, aLength);
}

//
//	Configure the lexer to reflect successful parsing of a categorised string.
//
//	If !isPrefixed the required string is precisely semeText[aLenth].
//
//	If isPrefixed the source someText[aLength] should correspond to the parsed text including any
//	L or " prefix but excluding any " suffix. In this way the return can indicate whether a wide
//	character has been detected and the routine can accommodate a variety of erroneous terminations.
//
void FogLexer::got_string(FogTokenRef& yyValue, const char* someText, size_t aLength, bool isPrefixed) {
	bool isWide = false;
	
	if (isPrefixed && someText && aLength) {
		if (*someText == 'L') {
			isWide = true;
			someText++;
			aLength--;
		}
		
		if (!aLength || (*someText != '"'))
			ERRMSG("BUG - bad start of string literal.");
			
		if (aLength) {
			someText++;
			aLength--;
		}
	}
	
	if (isWide)
		yyValue = FogTokenType::make_wide_string(someText, aLength);
	else
		yyValue = FogTokenType::make_narrow_string(someText, aLength);
}

//
//	Configure the lexer to start processing sourceFile, setting the declaration mode to aUtility.
//
void FogLexer::include_file(const FogSourceFile& sourceFile, const FogUtility& aUtility) {
	const PrimId& fileName = sourceFile.full_file_name();
	CONDMSG(Fog::debug_lex() || Fog::debug_input(), state() << " Including " << c_string(fileName.str()));
	PrimAdopted<std::istream> aStream(new std::ifstream(fileName.str()));
	PrimError anError;
	
	if (!aStream)
		ERRMSG("Failed to allocate memory to read " << c_string(fileName.str()));
	else if (!*aStream)
		ERRMSG("Failed to to open " << c_string(fileName.str()) << ", " << anError);
	else {
		std::istream* newStream = push_buffer(fileName, aStream, YY_CURRENT_BUFFER, aUtility, sourceFile);
		yy_switch_to_buffer(yy_create_buffer(newStream, YY_BUF_SIZE));
		begin(initial_state);
	}
}

std::ostream& FogLexer::print_depth(std::ostream& s, int aDepth) const {
	s << indent(aDepth) << "FogLexer(" << state() << ")\n";
	return Super::print_depth(s, aDepth);
}

std::ostream& FogLexer::print_members(std::ostream& s, int aDepth) const {
	s << indent(aDepth) << "FogLexer(" << state() << ")\n";
	return Super::print_members(s, aDepth);
}

std::ostream& FogLexer::print_statistics(std::ostream& s) {
	s << "tokens = " << _tokens << '\n';
	s << "body-tokens = " << _body_tokens << '\n';
	return s;
}

std::ostream& FogLexer::print_this(std::ostream& s) const {
	s << state();
	s << ", ";
	return Super::print_this(s);
}

void FogLexer::set_truth(bool isEnabled) {
	if (isEnabled) {
		if (_state == &off_state)
			begin(*_pre_off_state);
	}
	else {
		if (_state != &off_state)
			_pre_off_state = &begin(off_state);
	}
}

//
//	Return the state name.
//
//	This method is supplied out-of-line to bypass a declaration ordering problem.
//
const char* FogLexer::state_name() const { return state()._name; }

//
//	Generate a warning diagnostic using msg to explain a problem with respect to the source context.
//
//void FogLexer::warning(const char *msg) { WRNMSGZ(msg); }

//
//	Catch the lexer default processing of an unintelligible input character.
//
void FogLexer::yy_echo() {
	ERRMSG("BUG - should not resort to invocation of yyecho() for " << c_string(yytext, yyleng));
}

//
//	Acquire some more input to buffer[max_size] returning the number of characters to result.
//	Returns result, which is -1 at end of input.
//
int FogLexer::yy_input(char* buffer, int& result, int max_size) {
	result = yyin ? get_line(*yyin, buffer, max_size) : 0;
	return result;
}

//
//	Restore the previous source file reading context from the stack.
//
int FogLexer::yy_wrap() {
	CONDMSG(Fog::debug_lex() || Fog::debug_input(),
	        state() << " End of " << c_string(current_line().file().full_file_name().str()));
	struct yy_buffer_state* poppedBuffer = pop_buffer();
	
	if (!poppedBuffer)
		return 1;
		
	struct yy_buffer_state* deadBuffer = YY_CURRENT_BUFFER;
	yy_switch_to_buffer(poppedBuffer);
	yy_delete_buffer(deadBuffer);
	//
	//	There is no need to restore any state, since input is a continuous flow process and so whatever
	//	state is in use at the end of one buffer is correct for the subsequent continuations. The only
	//	state change for buffer changes is enforcement of initial_state at the start of an include.
	//
	return 0;
}
